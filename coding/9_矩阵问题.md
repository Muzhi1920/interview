# 矩阵
涉及矩阵：DFS,BFS，$N^2$技巧遍历,

---
- 被围绕的区域
```cpp
遍历：
    如果在四周的位置找到了O，则由此开始BFS；队列存储的是当前位置（i*n+j）
    非空时：
        获取当前点下标(x,y)；
        判断当前点的上是否为O，如果是替换为其他字符
        判断当前点的下是否为O，如果是替换为其他字符
        判断当前点的左是否为O，如果是替换为其他字符
        判断当前点的右是否为O，如果是替换为其他字符
遍历完后周边的O都被渗透换位其他字符，此时只要一个N^2的遍历将O替换为X，将其他字符改回O即可。
```

- 最大矩形
```cpp
dp[m][n]
遍历：
    如果当前为1，那么dp就是左侧值+1  //记录连续的1构成的最大长度，而且连续的1构成当前正方形
遍历：
    如果当前非0，更新最大元素为正方形的最大值；
    从当前往上遍历：
        更新最大值=max(获取最小的值*上移步数) //边长不为1的
return res
```
- 二维矩阵的搜索
右上角出发

- 矩阵最小乘次

n^3复杂度：确定长度step；遍历所有可能窗口；在该窗口下找分割点；
```cpp
//矩阵维数，矩阵i的维数为d[i]*d[i+1]
for(int i=1;i<=n;i++)
    m[i][i]=0;
for(int step=1;step<=n-1;step++){
    for(int i=1;i<=n-step;i++){
        int j=i+step;
        int minx=inf;
        for(int k=i;k<=j-1;k++){
            if(minx>(m[i][k]+m[k+1][j]+d[i]*d[k+1]*d[j+1])){
                minx=m[i][k]+m[k+1][j]+d[i]*d[k+1]*d[j+1];
                p[i][j]=k;
            }
        }
        m[i][j]=minx;
    }
}
cout<<m[1][n]<<endl;//最少乘法次数
```


