# 二叉树
对于树的问题，**涉及两个或多个问题则考虑最终使用哪一种遍历方式解决**

---
默认对树的层数定义为： 1,2,3,4……k……h  总结点数N；度为0：n0，度为1：n1，度为2：n2
- 性质1
: 树的第 k 层至多有$2^{k-1}$个节点
- 性质2
: 树深度为 n ，总结点数至多$2^{n}-1$
- 性质3
: 叶节点数$n_0$，度数为2的结点树$n_2$ 则有${n_0}={n_2}+1$ 如果一棵完全二叉树的结点总数为N，那么叶子结点${n_0}=\frac{N}{2}$
- 性质4
: 结点总数为N，则树深为${log_2(N+1)}$
### 遍历
前序，中序，后序。不同题目应用遍历方式是不同的。有的公司面试会问你非递归实现
```cpp
//用栈实现树的非递归遍历
//先序遍历
vector<int> preorderTraversal(TreeNode* root) {
    stack<TreeNode*> s;
    TreeNode *p = root;
    while (!s.empty() || p) {
        if (p) {
            cout<<(p->val);
            s.push(p);
            p = p->left;
        } else {
            TreeNode *t = s.top(); s.pop();
            p = t->right;
        }
    }
    return res;
}
//递归实现前序遍历
void preorder(TreeNode *root, vector<int> &path){
    if(root != NULL){
        cout<<(root->val);
        preorder(root->left, path);
        preorder(root->right, path);
    }
｝
//中序遍历
vector<int> inorderTraversal(TreeNode* root) {
    stack<TreeNode*> s;
    TreeNode *p = root;
    while (!s.empty() || p) {
        if (p) {
            s.push(p);
            p = p->left;
        } else {
            p = s.top(); s.pop();
            cout<<(p->val);
            p = p->right;
        }
    }
    return res;
}
//递归实现中序遍历
void inorder(TreeNode *root, vector<int> &path){
    if(root != NULL){
        inorder(root->left, path);
        cout<<(root->val);
        inorder(root->right, path);
    }
}
//后序遍历，与先序左右倒置，且头部插入保存
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> s;
    TreeNode *p = root;
    while(!s.empty() || p) {
        if(p){
            res.insert(res.begin(), p->val);
            s.push(p);
            p = p->right;
        } else {
            TreeNode *t = s.top();s.pop();
            p = t->left;
        }
    }
    return res;
}
//递归实现后序遍历
void postorder(TreeNode *root, vector<int> &path){
    if(root != NULL){
        postorder(root->left, path);
        postorder(root->right, path);
        path.push_back(root->val);
    }
}
//******************层序遍历******************
使用队列取出弹出加入左右；之字形用两个栈交替加入左右，右左。
```
- 路径和：只能是先序遍历
```cpp
help(node*,curSum,out,res){
    if(!node)
        return;
    out.push_back(node->val);
    if(!node->left && !node->right &&curSum==0)
        res.push_back(out);
    help(left,curSum-node->val,out,res);
    help(right,curSum-node->val,out,res);
    out.pop_back(node->val);
}
```
- 二叉树横向连接
```cpp
TreeNode* dummy=cur;
while(root){
    if(left)
        cur->next=left;
    if(right)
        cur->next=right;
    root=root->next;
    //换层
    if(!root){
        root=dummy->next;
        cur=dummy;
        dummy->next=NULL;
    }
}
```
- 二叉树右视图
```cpp
while(!Q.empty()){
    res(Q.back());
    for(int i=0;i<Q_size();i++){
        d=Q.top();Q.pop();
        if(d->left)
            Q.push(left)
        if(d->right)
            Q.push(right)
    }
}
```
- 子树
```cpp
bool main(s,t){
    if(!s)
        return false；
    if g(s,t)
        return true;
    return g(s->left,t) || g(s->right,t);
}

bool g(s,t):
    if(!s && !t) return true;
    if(!s || !t) return false;
    if(s->val!=t->val)
        return false;
    return g(s->left,t->left) && g(s->right,t->right);
```
- 公共祖先（二叉树，二叉搜索树）
```cpp
//如果二叉搜索树
//当前大于较大值：两节点在左子树上；
//当前小于较小值：两节点在右子树上。
TreeNode* generate(TreeNode* root, TreeNode* p, TreeNode* q) {
    若空则返回空
    if root->val > max(p->val, q->val)
        return generate(root->left, p, q)
    if root->val < min(p->val, q->val)
        return generate(root->right, p, q)
    return root; //p,q之间则找到
}
//一般树
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || p == root || q == root) 
        return root;
    TreeNode *left = lowestCommonAncestor(root->left, p, q);
    TreeNode *right = lowestCommonAncestor(root->right, p , q);
    if (left && right)
        return root;
    return left ? left : right;
}
```
- 翻转二叉树
```cpp
TreeNode* invertTree(TreeNode* root) {
    if (!root) 
        return NULL;
    TreeNode *tmp = root->left;
    root->left = invertTree(root->right);
    root->right = invertTree(tmp);
    return root;
}
```
- 二叉树中找重复子树
二叉树每棵子树序列化为字符串，用map<str,int>来存储;当==1则说明重复子树
>>string str = to_string(node->val) + "," + helper(node->left, m, res) + "," + helper(node->right, m, res);
```cpp
string helper(TreeNode* node, unordered_map<string, int>& m, vector<TreeNode*>& res) {
    if (!node) 
        return "#";
    string str = to_string(node->val) + "," + helper(node->left, m, res) + "," + helper(node->right, m, res);
    if (m[str] == 1) 
        res.push_back(node);
    ++m[str];
    return str;
}
```
- 二叉树的打家劫舍
```cpp
int rob(TreeNode* root) {
    int l = 0, r = 0;
    return helper(root, l, r);
}
int helper(TreeNode* node, int& l, int& r) {
    if (!node)
        return 0;
    int ll = 0, lr = 0, rl = 0, rr = 0;
    l = helper(node->left, ll, lr);
    r = helper(node->right, rl, rr);
    return max(node->val + ll + lr + rl + rr, l + r);
}
```

## 二叉搜索树（二叉排序树）
左子树的值<当前节点值<右子树的值
优点在于，最坏的情况下，搜索插入删除的复杂度为$O(h)=O({log_2N})$。
>>**可构造树的种数：![avatar](https://img-blog.csdn.net/20180327204239815)

- 构造：基于给定数值构造不同的二叉搜索树

遍历start~end选择中间节点，然后(start~i-1),(i+1,end)
```cpp
vector<TreeNode*> helper(int start, int end) {
    if (start > end) 
        return {nullptr};
    vector<TreeNode*> res;
    for (int i = start; i <= end; ++i) {   
        auto left = helper(start, i - 1);
        auto right = helper(i + 1, end);
        for (auto a : left) {
            for (auto b : right) {
                TreeNode *node = new TreeNode(i);
                node->left = a;
                node->right = b;
                res.push_back(node);
            }
        }
    }
    return res;
}
非平衡的二叉搜索树;如果需要平衡的则需要i取中间值；截止条件就是如果相等则返回该值
```
- 验证二叉排序树：返回bool、先序遍历
```cpp 
定义递归 fun(root,INT_MAX,INT_MIN);
fun():
    if(!root):return true;
    if(root->val>mx or root->val <mn){
        return false;
    }
    return fun(left,mn,node->val) && fun(right,node->val,mx);
```
- 搜索第k小的值
```cpp
int kthSmallestDFS(TreeNode* root, int &k) {
    if (!root) 
        return -1;
    int val = kthSmallestDFS(root->left, k);
    if (k == 0) //先判断之前是否已找到
        return val;
    k--;
    if (k == 0) //再判断现在是否已找到
        return root->val;
    return kthSmallestDFS(root->right, k);
}
```
- 插入
对于给定值去二分搜索，一定会直到为空时，则是插入的位置
```cpp
TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (!root) 
        return new TreeNode(val);
    if (root->val > val) 
        root->left = insertIntoBST(root->left, val);
    else
        root->right = insertIntoBST(root->right, val);
    return root;
}
```
- 删除
```cpp
TreeNode* deleteNode(TreeNode* root, int key) {
    if (!root) 
        return NULL;
    if (root->val > key) {
        root->left = deleteNode(root->left, key);
    } else if (root->val < key) {
        root->right = deleteNode(root->right, key);
    } else {//找到了待删除节点
    //仅一个子节点，则将较小的左给当前删除节点
    if (!root->left || !root->right) {
        root = (root->left) ? root->left : root->right;
        } else {
            TreeNode *cur = root->right;
            while (cur->left) 
                cur = cur->left;
            root->val = cur->val;//将替换的值赋给删除值；再从待删除的右节点开始，找到替换值删掉
            root->right = deleteNode(root->right, cur->val);
        }
    }
    return root;
}
```
- 恢复：Morris遍历基础上判断pre和cur的值是否满足条件
```cpp
//Morris中序遍历
void MorrisInOrderTraverse(Node *head){
	if (head == NULL){
		return;
	}
	Node *cur = head;
	Node *pre = NULL;
	while (cur != NULL){
		pre = cur->left;
		if (pre != NULL){
			while(pre->right && pre->right != cur){
				pre = pre->right;
			}
			if (pre->right == NULL){
				pre->right = cur;
				cur = cur->left;
				continue;
			}
			else{
				pre->right = NULL;
			}
		}
		cout<<cur->val<<" ";
		cur = cur->right;
	}
}
void recoverTree(TreeNode* root) {
    TreeNode *first = NULL, *second = NULL;
    TreeNode *curr = root;
    TreeNode *pre =NULL ;
    while (curr) {
        TreeNode *p = curr->left;
        if (p!= NULL){
            while (p->right && p->right != curr)
                p = p->right;
            //最右连接cur节点，如果连接则断开，如果断开则连接
            if (p->right == NULL) {
                p->right = curr;
                curr = curr->left;
                continue;
            }
            else
                p->right = NULL;
        }
        //Morris遍历基础上+判断cur和pre
        if (pre && curr->val < pre->val){
          if (!first) 
              first = pre;
          second = curr;
        }
        pre = curr;
        curr = curr->right;
    }
    swap(first->val, second->val);
}
```

- 实现二叉搜索树迭代器
```cpp
//迭代器首先将左入栈
BSTIterator(TreeNode *root) {
    while (root) {
        s.push(root);
        root = root->left;
    }
}
//Core code
int next() {
    t=s.back();pop_back();
    s.push_back(right,right-->->left)
}
```

## 二叉平衡树
两个子树的深度不想差超过1. 简单测试过可以。
- 是否平衡
```cpp
int help(node){
    if(!node) return 0;
    l=help(node->left);
    if(l==-1)
        return -1;
    r=help(node->right);
    if(r==-1)
        return -1;
    return abs(l-r)>1?-1:1+max(l,r);
}
```
- 二叉平衡且排序的树
```cpp
int helper(TreeNode* node,int mx,int mn){
    if(!node){
        return 0;
    }
    int l=helper(node->left,mn,node->val)+1;
    int r=helper(node->right,node->val,mx)+1;
    if(abs(l-r)>1 || l==0 || r==0 ||(node->left && node->val<=node->left->val) || (node->right && node->val>=node->right->val)){
        return -1;
    }else{
        return max(l,r);
    }
}
```
## 二叉树与链表
- 先序遍历将二叉树转单向链表
```cpp
while(cur){
    if(cur->left){
        pre=root->left;
        while(pre->right){
            pre=pre->right;
        }
        pre->right=cur->right;//左最右连接右
        cur->right=cur->left;//right指针实现next
        cur->left=NULL;//左置空
    cur=cur->right;  //其实是进入左子树
```
- 二叉树转双向链表：按照中序遍历则是递增。
```cpp
TreeNode *head = NULL;
TreeNode *tail = NULL;
TreeNode convertTreeToList(TreeNode *root){
	if(!root)
        return NULL;
	convertTreeToList(root->left);//至左
    //中序
	root->left = tail;
	if (tail == NULL) //左右连接
		tail = head = root;
	else
		tail->right = root;
	tail = root;

	convertToList(root->right);//至右
return head;
}
//全左接右
while (root || !s.empty()) {
    while (root) {
        s.push(root);
        root = root->left;
    }
    root = s.top(); s.pop();
    //此处仅保留头结点
    if (!head)
        head = root;
    if (pre) {
        pre->right = root;
        root->left = pre;
    }
    pre = root;
    root = root->right;
}
//不仅双向还循环
head->left = pre;
pre->right = head;
return head;
```

- 完全二叉树的节点数
```cpp
f(node){
    l,r=0;
    while(!node->left)
        node=node->left;l++;
    while(!right)
        node=node->right;r++;  //计算左右深度
    if(l==r){
        N=(2^l)-1;
    }
    else{
        return f(left)+f(right)+1;
    }
}
```