<!-- TOC -->

- [数组](#数组)
    - [一维数组](#一维数组)
        - [平生不识TwoSum，刷尽力扣也枉然](#平生不识twosum刷尽力扣也枉然)
        - [连续子数组最大和](#连续子数组最大和)
        - [数组拼接成最小（大）数](#数组拼接成最小大数)
        - [数组编解码](#数组编解码)
        - [返回数组内缺失的第一个正整数](#返回数组内缺失的第一个正整数)
        - [寻找重复数](#寻找重复数)
            - [环的快慢指针实现寻找重复数](#环的快慢指针实现寻找重复数)
            - [循环排序实现寻找重复数](#循环排序实现寻找重复数)
            - [二分查找实现寻找重复数](#二分查找实现寻找重复数)
        - [数组中超过一半的数](#数组中超过一半的数)
        - [最小的k个数](#最小的k个数)
        - [数组（数据流）中位数](#数组数据流中位数)
        - [众数](#众数)
        - [滑动窗口](#滑动窗口)
            - [滑动窗口最大值](#滑动窗口最大值)
            - [滑动窗口中位数：](#滑动窗口中位数)
            - [两个索引满足下标差和数值差](#两个索引满足下标差和数值差)
            - [长度最小的子数组。和相同（双指针）](#长度最小的子数组和相同双指针)
    - [二维数组](#二维数组)
        - [行列递增数组的查找](#行列递增数组的查找)

<!-- /TOC -->
<a id="markdown-数组" name="数组"></a>
# 数组


<a id="markdown-一维数组" name="一维数组"></a>
## 一维数组

<a id="markdown-平生不识twosum刷尽力扣也枉然" name="平生不识twosum刷尽力扣也枉然"></a>
### 平生不识TwoSum，刷尽力扣也枉然

```cpp
//{1, 1, 2, 3, 4, 4, 4, 7, 7, 8, 9, 10},8
vector<pair<int, int>> twoSum(vector<int> nums, int target) {
    map<int, int> m;
    vector<pair<int, int>> res;
    for (int i = 0; i < nums.size(); ++i) {
        m[nums[i]]++;
    }
    for (int i = 0; i < nums.size(); ++i) {
        if (m[target - nums[i]] > 0) {
            if (nums[i] == target / 2 && m[nums[i]] == 1)
                continue;
            res.push_back(make_pair(nums[i], target - nums[i]));
            m[target - nums[i]]--;
            m[nums[i]]--;
        }
    }
    return res;
}
```

<a id="markdown-连续子数组最大和" name="连续子数组最大和"></a>
### 连续子数组最大和
>> 最大和以及下标

```cpp
int res=curSum=num[0];
int L, R, pos;
for (int i = 1; i < nums.size(); i++){
    if (curSum < 0)
        curSum = nums[i], pos = i;
    else
        curSum += nums[i];
    if (curSum > res)
        res = curSum, L = pos, R = i;
}
cout << L << ',' << R << endl; //连续下标
cout << res; //最大子序列和
```

<a id="markdown-数组拼接成最小大数" name="数组拼接成最小大数"></a>
### 数组拼接成最小（大）数

```cpp
//递增排序，得到最小数；递减排序，得到最大数
int compare(string s1, string s2) {
    return s1 + s2 < s2 + s1;
}
void minNums(vector<int> nums) {
    vector<string> ss;
    for (int num:nums) {
        ss.push_back(to_string(num));
    }
    sort(ss.begin(), ss.end(), compare);
    for (int i = 0; i < nums.size(); ++i)
        cout << ss[i];
}
```


<a id="markdown-数组编解码" name="数组编解码"></a>
### 数组编解码
>>给定0~N-1的N个数，对编码后的数恢复原数据，进行解码
原数组B：3,1,2,0,4
编码后A：0,0,1,0,4

```cpp
int N = 5;
for (int mn = 0; mn < N; mn++) {
    for (int i = N - 1; i >= 0; i--) {
        if (A[i]-- == 0) {
            B[i] = mn;
            break;
        }
    }
}
```

<a id="markdown-返回数组内缺失的第一个正整数" name="返回数组内缺失的第一个正整数"></a>
### 返回数组内缺失的第一个正整数
对应下标：0~N-1；
正整数位：1~N；

```cpp
for(int i=0;i<nums.size();i++){
    while(1<=nums[i]<=N) && (nums[i]!=nums[nums[i]-1]){ //nums[i]不在i-1位置上
        swap(num[i],nums[i-1]);
}
for(int i=0;i<nums.size();i++){
    if(nums[i]!=i+1):
        return i+1;
}
return N+1; //都满足条件，返回N+1
```

<a id="markdown-寻找重复数" name="寻找重复数"></a>
### 寻找重复数
<a id="markdown-环的快慢指针实现寻找重复数" name="环的快慢指针实现寻找重复数"></a>
#### 环的快慢指针实现寻找重复数
>>在下标范围内，对数值索引会得到一个环，环的起点就是重复数字；同有环链表。查找N+1个数字，范围在[1,N]

```cpp
while(1){
    slow=num[slow];
    fast=num[num[fast]];
    if(slow ==falst) //在环中相遇
        break;
}
slow=head;
while(1){
    slow=num[slow];
    fast=num[fast];
    if(slow ==fast)  //环中继续走，头开始走。走相同距离相遇即为起点
        break;
}
return slow;
```

<a id="markdown-循环排序实现寻找重复数" name="循环排序实现寻找重复数"></a>
#### 循环排序实现寻找重复数
>>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。N个数字都在[0,N-1]]的范围内。

```cpp
for(int i = 0; i < nums.size(); ++i){
    while(nums[i] != i){
        if(nums[i] == nums[nums[i]])
            *duplication = nums[i];
            return true;
        swap(nums[i],nums[nums[i]]);
    }
}
```

<a id="markdown-二分查找实现寻找重复数" name="二分查找实现寻找重复数"></a>
#### 二分查找实现寻找重复数
[二分查找](./6_binarySearch.md)


<a id="markdown-数组中超过一半的数" name="数组中超过一半的数"></a>
### 数组中超过一半的数

```cpp
int half(vector<int>nums) {
    int res = nums[0];
    int times = 1;
    for (int i = 1; i < nums.size(); ++i) {
        if (times == 0) {
            res = nums[i];
            times = 1;
        } else if (nums[i] == res)
            times++;
        else
            times--;
    }
    if (!check(nums,res))
        res = 0;
    return res;
}
```








<a id="markdown-最小的k个数" name="最小的k个数"></a>
### 最小的k个数
>>4,5,1,6,2,7,3,8  O(k*n)=O(n)

```cpp
int partition(vector<int> nums, int start, int end){
    int key = nums[start];
    while (start < end) {
        //从右找小于key的值，赋给start
        while (start < end and nums[end] >= key)
            end --;
        nums[start] = nums[end];
        //从左找大于key的值，赋给end
        while (start < end and nums[start] <= key)
            start ++;
        nums[end] = nums[start];

        //key赋给start
        nums[start] = key;
    }
    return start;
}
vector<int> GetLeastNumbers(vector<int> input, int k){
    vector<int>output;
    int start = 0;
    int end = input.size() - 1;
    int index = partition(input,start,end);
    while(index != k - 1){
        if(index > k - 1){
            end = index - 1;
            index = partition(input,start,end);
        }
        else{
            start = index + 1;
            index = partition(input,start,end);
        }
    }
    for(int i = 0; i < k; ++i)
        output.push_back(input[i]);
}
```

<a id="markdown-数组数据流中位数" name="数组数据流中位数"></a>
### 数组（数据流）中位数

```cpp
priority_queue<long> small, large;
void addNum(int num) {
    small.push(num);
    large.push(-small.top());
    small.pop();
    if (small.size() < large.size()) {
        small.push(-large.top());
        large.pop();
    }
}
double findMedian() {
    return small.size() > large.size() ? small.top() : 0.5 * (small.top() - large.top());
}
```


<a id="markdown-众数" name="众数"></a>
### 众数
>>找到超过某个数量的数字

```cpp
int base=nums[0];
for(int i=1;i<nums.size();i++){
    if(nums[i]==base);
        times++;
    else：
        times--;
    if(times==0)
        base=nums[i];
        times=1;
}
for(int i=0;i<nums.size();i++){
    if(nums[i]==base)
        count++;
}
return count==num;
```

<a id="markdown-滑动窗口" name="滑动窗口"></a>
### 滑动窗口

<a id="markdown-滑动窗口最大值" name="滑动窗口最大值"></a>
#### 滑动窗口最大值
>>一般窗口固定的话，就是一次移一个得到某个结果值
- Q1：何时将结果push到res?i-left>=-1时此刻开始push第一个。
- Q2：如何判断窗口后移之前最大值pop?保留的是下标，下标top()=i-k时pop掉。
- Q3：期间有大的还要替换前面比它小的

```cpp
//双向队列保存当前最大值下标
deque<int>q;
for(int i=0;i < nums.size();i++){
    if(!q.empty() && q.front()<=i-k)//较大值窗口之外
        q.pop_front();
    while(!q.empty() && nums[i]>q.back())
        q.pop_back();
    q.push(i);
    if(i-k>=-1)
        res.push(q.front())
}
```
<a id="markdown-滑动窗口中位数" name="滑动窗口中位数"></a>
#### 滑动窗口中位数：
>>直观的解法就是每个窗口排序取中位数。借用multiset，可重复的有序集合，mid指针始终指向中间位置；而且中间位置的元素也有技巧去唯一获取。

```cpp
multiset<int> ms(nums.begin(), nums.begin() + k);//初始化
auto mid = next(ms.begin(), k / 2);//取当前中间或偏右位置
res.push((*mid+*prev(mid,1-k%2))/2);//取当前中位数
for (int i = k;i<nums.size(); ++i) {
    ms.insert(nums[i]);
    //新插入元素在左边
    if (nums[i] < *mid)
        --mid;
    //新删除元素在左边
    if (nums[i - k] <= *mid)
        ++mid;
    //二分查找删除元素
    ms.erase(ms.lower_bound(nums[i - k]));
    res.push_back((*mid + *prev(mid,  1 - k % 2)) / 2);
}
```

<a id="markdown-两个索引满足下标差和数值差" name="两个索引满足下标差和数值差"></a>
#### 两个索引满足下标差和数值差
```cpp
map<int int> m;int j = 0;
for (int i = 0; i < nums.size(); ++i) {
    if (i - j > k)
        m.erase(nums[j]);
        j++;
    //寻找第一个大于等于(nums[i]-t)的数,小于的nums[i]的差的绝对值会大于t 
    auto a = m.lower_bound((long long)nums[i] - t);
    if (a != m.end() && abs(a->first - nums[i]) <= t)
        return true;
    m[nums[i]] = i;
}
return false;
```

<a id="markdown-长度最小的子数组和相同双指针" name="长度最小的子数组和相同双指针"></a>
#### 长度最小的子数组。和相同（双指针）
>>一直累加，当超过目标值时左边移动

```cpp
int sum,res,left;
for(int i=0;i<nums.size();i++){
    sum+=nums[i];
    while(left<=i && sum>=Target){
        res=min(res,i-left+1);
        sum-=num[left];
        left++;
    }
}
return res==INT_MAX?0:res;
```



<a id="markdown-二维数组" name="二维数组"></a>
## 二维数组

<a id="markdown-行列递增数组的查找" name="行列递增数组的查找"></a>
### 行列递增数组的查找

```cpp
bool searchMatrix(vector<vector<int>>& nums, int target){
    if(nums.size()==0 || nums[0].size()==0)
        return false;
    //列二分，核心判断在哪一行通过mid和mid+1
    int l = 0, r = nums.size();
    int j, mid=0;
    while (l < r) {
        mid = (l + r) / 2;
        if (nums[mid][0] == target)
            return true;
        else if (nums[mid][0] > target) {
            r--;
        } else {
            if (mid+1 < nums.size() && nums[mid + 1][0] > target)
                break;
            l++;
        }
    }
    j = mid;
    l = 0;
    r = nums[0].size();
    //对j行再进行二分
    while (l < r) {
        mid = (l + r) / 2;
        if (nums[j][mid] == target)
            return true;
        else if (nums[j][mid] > target) {
            r--;
        } else {
            l++;
        }
    }
    return false;
}
```







