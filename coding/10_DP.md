## 动态规划
字符串匹配，两个字符串的问题，二位数组的最值问题等。故将字符串问题也写入DP

---

- 最大正方形
由0-1构成的矩阵，找到1构成的最大正方形
```cpp
dp[m][n]={0}
遍历：
    if 在边界:
        dp[i][j]=m[i][j]；
    else if 内部值为1：
        dp[i][j]=min(上，左，左上)+1 //以当前为右下角的正方形，最小边长
    保存最大dp[i][j]
返回res*res
```

- 贪心，最少加油次数
```cpp
最大堆存油量，加当前经过的最大的
遍历站：
    当前油量<到达当前站的所需油量时：
        如果还可以加油：
            加最多的；
        不可以，返回-1；
    堆存储经过的站的油量
return 站数-油堆大小
```

- 最长上升子序列：
```cpp
栈初始化nums[0]
遍历：
    if 大于栈顶：
        push
    else ：
        二分查找当前值位置，或者可插入位置：
        更新栈值
```

-最长公共子序列
相同则(左上)+1;不同则当前值为左和上的最大；0代表左上到达；1代表上到达；-1代表作到达；
如果是字串相同时：dp[i,j]=dp[i-1,j-1]+1；否则不同则当前为0；res保存最大值即可
```cpp
二维的dp[len1+1,len2+1]
二维遍历：
    if 字符相等：
        dp[i][j]=dp[i-1][j-1]+1;
        b[i][j]=0;
    else if 字符不同左长度更大:
        dp[i][j]=dp[i-1][j]
        b[i][j]=1
    else 字符不同右长度更大:
        dp[i][j]=dp[i][j-1]
        b[i][j]=-1
返回最后的右下角的值
```
- 最长回文子序列
```cpp
//翻转得到两个字符串然后求LCS。
//dp[i,j]：代表[i,j]间最长回文序列长度；如果s[i]==s[j]则dp[i,j]=dp[i+1,j-1]+2。中间往外+2个字符；否则不相等则取上和左最大
for(int i=n-1;i>=0;i++){
    dp[i][i]=1
    for(int j=i+1;j< n;j++){
        相等：
            dp[i+1,j-1]+2;//子问题：找到j。当前区间[i,j]内的最长长度。
        不相等：
            max
    }
}
return dp[0,n-1];
```




## DP无关
- 计算器
保存连续的两个运算符op,c：计算之前云算符op；同时判断当前c是+-时中间结果累加到res。
```cpp
遍历stirng：
    如果是字符：
        num=num*10+c-'0'
    如果是运算符(+-*/或者字符串到头)：
        switch(op)：{  //结算上一运算符
        }
        if(当前字符是+-或者到头)：
            当前结果累加到res，当前结果归0
        op=c
        num=0
return res
```