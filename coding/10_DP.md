## 动态规划
字符串匹配，两个字符串的问题，二位数组的最值问题等。故将字符串问题也写入DP

---

- 最大子数组和，最大子矩阵和
>>网易
```cpp
for(int i=1;i<=n;i++){//从第i行开始加
    for(int j=i;j<=n;j++){//加到第j行
        for(int k=1;k<=n;k++){//第j行各个列的值
            b[j][k]=a[j][k]+b[j-1][k];
        }
        solve(j);
    }
}

void solve(int j){
    for(int i=1;i<=n;i++){
        dp[i]=max(b[j][i],dp[i-1]+b[j][i]);
        mx=max(mx,dp[i]);
    }
}
```

- 求取子矩阵的和
```cpp
void fun(vector<vector<int>> &nums) {
    vector<vector<int>> dp(nums.size()+1,vector<int>(nums[0].size()+1));
    for (int i = 1; i <= nums.size(); ++i) {
        for (int j = 1; j <= nums[0].size(); ++j){
            //上+左-到[i-1,j-1]的重复路径+本地元素
            dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + nums[i - 1][j - 1];
        }
    }
}
int main(int row1, int col1, int row2, int col2) {
    return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];
}
```

- 最大正方形
由0-1构成的矩阵，找到1构成的最大正方形
```cpp
dp[m][n]={0};//以当前为右下角构成的正方形，最小边长
二维遍历：
    if(i==0||j==0):
        dp[i][j]=m[i][j]-'0';//边界值同原矩阵
    else if(matrix[i][j]=='1')：
        dp[i][j]=min({-1,-1},{-1,0},{0,-1})+1;
    res=max(res,dp[i][j]);
return res*res;
```

- 贪心，最少加油次数
```cpp
priority_queue<int,vector<int>,less<int>q;
stations({target,0});//加入终点
遍历加油站://station{里程，可加油量}
    while(cur<station[0]){
        if(q.empty()):
            return -1;
        cur+=q.top();q.pop();
    }
    q.push(station[1])
return stations.size()-q.size();
```

- 移除K个数字使得值更小
```cpp
for (char c : num) {
    //从前往后，有比当前大的就替换。保证排在前面的更小
    while (k && res.size() && res.back() > c)
        res.pop_back();
        --k;
    if (res.size()==0 && c== '0')
        continue;
    res.push_back(c);
}
while (res.size() && k--) 
    res.pop_back();
return res.empty() ? "0" : res;
```

- 最长上升子序列：
```cpp
stack ss{nums[0]};
遍历nums：
    auto it = lower_bound(v.begin(), v.end(),num);//二分查找该值
    if (it == v.end())
        v.push(a);
    else 
        *it = a;//替换该值
return ss.size();
```

- 最长公共前缀
```cpp
sort(strs.begin(), strs.end());
int i = 0, len = min(strs[0].size(), strs.back().size());
while (i < len && strs[0][i] == strs.back()[i]) 
    ++i;
return strs[0].substr(0, i);
```

- 最长公共子序列
![avatar](https://pic002.cnblogs.com/images/2012/214741/2012111100085930.png)
```cpp
//M=s1.size();N=s2.size();
//dp[N+1][M+1] 从[1,1]开始免去边界判断
for(i=1;i<=s1.size();i++){
    for(j=1;j<=s2.size();j++){
        if(a[i-1]==b[j-1]){
            dp[i][j]=dp[i-1][j-1]+1;
        }else{
            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
    }
}
printf("%d\n",dp[M][N]);

//对dp数组回溯得到子序列
string res(dp[m][n]);
i= res.length-1;
while(i >= 0){
    if(n>0 && dp[m][n] == dp[m][n-1])//同左
        n--;
    else if(m>0 && dp[m][n] == dp[m-1][n])//同上
        m--;
    else{   //同斜上，则赋值
        res[i--] = s1[m];
        m--;n--;
    }
}
```

- 最长回文子串
>>对于给定字符串构造回文串，返回其最大长度
```cpp
int longestPalindrome(string s) {
    unordered_set< char > t;//只要set不为空则就有单独存在的
    for (char c : s) {
        if (!t.count(c))
            t.insert(c);
        else
            t.erase(c);
    }
    //return s.size() - max(0, (int)t.size() - 1);等价
    if(t.size()==0){
        return s.size();
    }else{
        return s.size()-t.size()+1;
    }
}
```

- 验证回文子串
>>忽略字母大小写
```cpp
boolean isPalindrome(string s) {
    if (s.length() == 0)
        return true;
    int l = 0, r = s.length() - 1;
    while (l < r) {
        if (!isLetterOrDigit(s[l]])) 
            l++;
        else if (!isLetterOrDigit(s[r]))
            r--;
        else
            if (lower(s[l]) != lower(s[r]))
                return false;
            l++;
            r--;
    }
    return true;
}
```

- 最长回文串
```cpp
int index, len;
string longestPalindrome(string s) {
    if (s.length() < 2)
        return s;
    for (int i = 0; i < s.length() - 1; i++)
        helper(s, i, i);
        helper(s, i, i + 1);
    return s.substr(index, index + len);
}
void helper(string s, int l, int r) {
    while (l >= 0 && r < s.length() && s[l] == s[r])
        l--;
        r++;
    if (len < r - l - 1)
        index = l + 1;
        len = r - l - 1;
}
```

- 最长回文子序列
![avatar](img/lcs.png)
```cpp
//翻转得到两个字符串然后求LCS，实际上只计算上三角
//dp[i,j]代表[i,j]间最长回文序列长度
for(int i=n-1;i>=0;i++){
    dp[i][i]=1
    for(int j=i+1;j< n;j++){
        if (s[i] == s[j]) {
            dp[i][j] = dp[i+1][j-1] + 2;//左斜下位置+2
        } else {
            dp[i][j] = max(dp[i+1][j], dp[i][j-1]);//左和下的最大
        }
    }
}
return dp[0,n-1];
```

- 最大乘积子序列
```cpp
int maxProduct(vector< int >& nums) {
    int res = nums[0], mx = res, mn = res;
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] > 0) {//当前为正，则比较乘之前最大和最小
            mx = max(mx * nums[i], nums[i]);
            mn = min(mn * nums[i], nums[i]);
        } else {
            int t = mx;//当前为负，最大是最小乘和当前相比；最小是当前最大乘和当前相比
            mx = max(mn * nums[i], nums[i]);
            mn = min(t * nums[i], nums[i]);
        }
        res = max(res, mx);
    }
return res;
}
```

- 正则表达式
```cpp
匹配0次
e b c
e a * b c 
匹配1次
e a a b c
e a * b c
vector<vector<bool>> dp(m + 1, vector< bool >(n + 1, false));
dp[0][0] = true;
//遍历字符串
for (int i = 0; i <= m; ++i) {
    //从1开始是因为考虑到*的存在会影响j的状态
    for (int j = 1; j <= n; ++j) {
        if (j > 1 && p[j - 1] == '*') {
                        //0次                   多次                                          前面都已匹配
            dp[i][j] = dp[i][j - 2] || (i > 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]);
        } else {
            //当前值相同且前面都已匹配
            dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
        }
    }
}
return dp[m][n];
```

- 最小编辑距离
```cpp
vector<vector<int>> dp(m + 1, vector< int >(n + 1));
for (int i = 0; i <= m; ++i)//空字符到当前w1的某个字符的编辑距离是长度
    dp[i][0] = i;
for (int i = 0; i <= n; ++i)//同上
    dp[0][i] = i;
for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= n; ++j) {
        if (word1[i - 1] == word2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1]; //字符相等，则当前编辑距离等于上一位置，也就是左上方
        } else {
            dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;//不相等则左，上，左上的最小+1
        }
    }
}
return dp[m][n];
```

- KMP
>>字符串匹配算法
```cpp
void KMP(string ss, string tmp, vector< int > f) {
    int n = ss.size(), m = tmp.size();
    process(temp, f); //预处理得到失配表
    int j = 0; //j表示当前模版串的待匹配位置
    for(int i = 0; i < n; ++i) {
        while(j && ss[i] != tmp[j]) 
            j = f[j]; //不停的转移，直到可以匹配或者走到0
        if(ss[i] == tmp[j])
            j++; //如果相等，模版串中待匹配位置可以移一位了。
        if(j == m)
            cout<< i - m + 1;
    }
}
//计算失配表
void process(string* tmp, vector< int > f) {
    int n = tmp.size();
    f[0] = f[1] = 0; //边界
    for(int i = 1; i < n; ++i) {
        int j = f[i];
        while(j && tmp[i] != tmp[j])
            j = f[j]; //一旦回到1，表明窗口大小为0了，只能回到最初的字符
        f[i + 1] = tmp[i] == tmp[j] ? j + 1: 0;
    }
}
```

- 矩阵的最小路径和
```cpp
//先对首行处理
for(int j=1;j < n;j++){
    dp[0][j]=dp[0][j-1]+grid[0][j];
}
//再对首列处理
for(int j=1;j < m;j++){
    dp[j][0]=dp[j-1][0]+grid[j][0];
}
for(int i=1;i < m;i++){
    for(int j=1;j < n;j++){
        dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];
    }
}
```

- 计算器
初始op为+，保存连续的两个运算符op,c：先结算op；然后判断当c是+-时将中间结果累加到res。
```cpp
char op = '+';
for(int i=0;i < n;i++){
    char c=s[i];
    //累计当前数
    if(c>='0' && c<='9'){
        num=num*10+c-'0';
    }
    if (c == '+' || c == '-' || c == '*' || c == '/' || i == n - 1){
        //计算中间结果
        switch(op):{
            case '+': curRes += num; break;
            case '-': curRes -= num; break;
            case '*': curRes *= num; break;
            case '/': curRes /= num; break;
        }
        //结算本次运算符
        if (c == '+' || c == '-' || i == n - 1) {
            res += curRes;
            curRes = 0;
        }
        //保存本次运算符
        op = c;
        num = 0;
    }
return res;
```