## 动态规划
字符串匹配，两个字符串的问题，二位数组的最值问题等。故将字符串问题也写入DP

---

- 最大正方形
由0-1构成的矩阵，找到1构成的最大正方形
```cpp
dp[m][n]={0};//以当前为右下角构成的正方形，最小边长
二维遍历：
    if(i==0||j==0):
        dp[i][j]=m[i][j]-'0';//边界值同原矩阵
    else if(matrix[i][j]=='1')：
        dp[i][j]=min({-1,-1},{-1,0},{0,-1})+1;
    res=max(res,dp[i][j]);
return=res*res;
```

- 贪心，最少加油次数
```cpp
priority_queue<int,vector<int>,less<int>q;
stations({target,0});//加入终点
遍历加油站://station{里程，可加油量}
    while(cur<station[0]){
        if(q.empty()):
            return -1;
        cur+=q.top();q.pop();
    }
    q.push(station[1])
return stations.size()-q.size();
```

- 最长上升子序列：
```cpp
stack ss{nums[0]};
遍历nums：
    auto it = lower_bound(v.begin(), v.end(),num);//二分查找该值
    if (it == v.end())
        v.push_back(a);
    else 
        *it = a;//替换该值
return ss.size();
```

- 最长公共子序列
![avatar](https://pic002.cnblogs.com/images/2012/214741/2012111100085930.png)

```cpp
//得到最大长度
dp[len1,len2]
for(i,j in a,b){//二维遍历
    if(i==0||j==0){
        dp[i][j] = (s1[i] == s2[j] ? 1:0);
    }else{
        dp[i][j] =max(dp[i-1][j],dp[i][j-1]);
        if(s1[i] == s2[j])
            dp[i][j] = max(dp[i][j],dp[i-1][j-1] + 1);
    }
}
return dp[M-1][N-1];

//对dp数组回溯得到子序列
m=M-1,n=N-1;
string res(dp[m][n]);
i= res.length-1;
while(i >= 0){
    if(n>0 && dp[m][n] == dp[m][n-1])//同左
        n--;
    else if(m>0 && dp[m][n] == dp[m-1][n])//同上
        m--;
    else{   //同斜上，则赋值
        res[index--] = s1[m];
        m--;n--;
    }
}

```
- 最长回文子序列
```cpp
//翻转得到两个字符串然后求LCS。
//dp[i,j]代表[i,j]间最长回文序列长度；如果s[i]==s[j]则dp[i,j]=dp[i+1,j-1]+2。中间往外+2个字符；否则不相等则取上和左最大
for(int i=n-1;i>=0;i++){
    dp[i][i]=1
    for(int j=i+1;j<n;j++){
        if (s[i] == s[j]) {
            dp[i][j] = dp[i+1][j-1] + 2;//原长度+2
        } else {
            dp[i][j] = max(dp[i+1][j], dp[i][j-1]);//保留最大长度
        }
    }
}
return dp[0,n-1];
```

- 最大乘积子序列
```cpp
int maxProduct(vector<int>& nums) {
    int res = nums[0], mx = res, mn = res;
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] > 0) {//当前为正，则比较乘之前最大和最小
            mx = max(mx * nums[i], nums[i]);
            mn = min(mn * nums[i], nums[i]);
        } else {
            int t = mx;//当前为负，最大是最小乘和当前相比；最小是当前最大乘和当前相比
            mx = max(mn * nums[i], nums[i]);
            mn = min(t * nums[i], nums[i]);
        }
        res = max(res, mx);
    }
return res;
}
```

- 正则表达式
```cpp
匹配0次
e b c
e a * b c 
匹配1次
e a a b c
e a * b c
vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
dp[0][0] = true;
for (int i = 0; i <= m; ++i) {
    for (int j = 1; j <= n; ++j) {
        if (j > 1 && p[j - 1] == '*') {
            //0次，多次且前面都已匹配
            dp[i][j] = dp[i][j - 2] || (i > 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]);
        } else {
            //当前值相同且前面都已匹配
            dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
        }
    }
}
return dp[m][n];
```

- 矩阵的最小路径和
```cpp
//二维遍历
if(j>0){
    dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];
}else{
    dp[i][j]=dp[i-1][j]+grid[i][j];
}

```

- 计算器
保存连续的两个运算符op,c：计算之前云算符op；同时判断当前c是+-时中间结果累加到res。
```cpp
for(auto c:s)：
    if(c>='0' && c<='9')：
        num=num*10+c-'0'
    if (c == '+' || c == '-' || c == '*' || c == '/' || i == n - 1) ：
        //计算中间结果
        switch(op)：{
            case '+': curRes += num; break;
            case '-': curRes -= num; break;
            case '*': curRes *= num; break;
            case '/': curRes /= num; break;
        }
        //结算本次运算符
        if (c == '+' || c == '-' || i == n - 1) {
            res += curRes;
            curRes = 0;
        }
        //保存本次运算符
        op = c;
        num = 0;
return res;
```