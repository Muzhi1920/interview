## 动态规划
字符串匹配，两个字符串的问题，二位数组的最值问题等。故将字符串问题也写入DP

---

- 最大正方形
由0-1构成的矩阵，找到1构成的最大正方形
```cpp
dp[m][n]={0};//以当前为右下角构成的正方形，最小边长
二维遍历：
    if(i==0||j==0):
        dp[i][j]=m[i][j]-'0';//边界值同原矩阵
    else if(matrix[i][j]=='1')：
        dp[i][j]=min({-1,-1},{-1,0},{0,-1})+1;
    res=max(res,dp[i][j]);
return=res*res;
```

- 贪心，最少加油次数
```cpp
priority_queue<int,vector<int>,less<int>q;
stations({target,0});//加入终点
遍历加油站://station{里程，可加油量}
    while(cur<station[0]){
        if(q.empty()):
            return -1;
        cur+=q.top();q.pop();
    }
    q.push(station[1])
return stations.size()-q.size();
```

- 移除K个数字使得值更小
```cpp
for (char c : num) {
//从前往后，有比当前大的就替换。保证排在前面的更小
    while (k && res.size() && res.back() > c) {
        res.pop_back();
        --k;
    }
    if (res.size()==0 && c== '0'){
        continue;
    }
    res.push_back(c);
}

while (res.size() && k--) 
    res.pop_back();
return res.empty() ? "0" : res;


```

- 最长上升子序列：
```cpp
stack ss{nums[0]};
遍历nums：
    auto it = lower_bound(v.begin(), v.end(),num);//二分查找该值
    if (it == v.end())
        v.push_back(a);
    else 
        *it = a;//替换该值
return ss.size();
```

- 最长公共子序列
![avatar](https://pic002.cnblogs.com/images/2012/214741/2012111100085930.png)

```cpp
//得到最大长度
for(i=1;i<=lena;i++){
    for(j=1;j<=lenb;j++){
        if(a[i-1]==b[j-1]){
            dp[i][j]=dp[i-1][j-1]+1;
        }else{
            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
    }
}
printf("%d\n",dp[lena][lenb]);

//对dp数组回溯得到子序列
m=M-1,n=N-1;
string res(dp[m][n]);
i= res.length-1;
while(i >= 0){
    if(n>0 && dp[m][n] == dp[m][n-1])//同左
        n--;
    else if(m>0 && dp[m][n] == dp[m-1][n])//同上
        m--;
    else{   //同斜上，则赋值
        res[index--] = s1[m];
        m--;n--;
    }
}

```
- 最长回文子序列
```cpp
//翻转得到两个字符串然后求LCS。
//dp[i,j]代表[i,j]间最长回文序列长度
for(int i=n-1;i>=0;i++){
    dp[i][i]=1
    for(int j=i+1;j<n;j++){
        if (s[i] == s[j]) {
            dp[i][j] = dp[i+1][j-1] + 2;//原长度+2
        } else {
            dp[i][j] = max(dp[i+1][j], dp[i][j-1]);//保留最大长度
        }
    }
}
return dp[0,n-1];
```

- 最大乘积子序列
```cpp
int maxProduct(vector<int>& nums) {
    int res = nums[0], mx = res, mn = res;
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] > 0) {//当前为正，则比较乘之前最大和最小
            mx = max(mx * nums[i], nums[i]);
            mn = min(mn * nums[i], nums[i]);
        } else {
            int t = mx;//当前为负，最大是最小乘和当前相比；最小是当前最大乘和当前相比
            mx = max(mn * nums[i], nums[i]);
            mn = min(t * nums[i], nums[i]);
        }
        res = max(res, mx);
    }
return res;
}
```

- 正则表达式
```cpp
匹配0次
e b c
e a * b c 
匹配1次
e a a b c
e a * b c
vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
dp[0][0] = true;
for (int i = 0; i <= m; ++i) {
    for (int j = 1; j <= n; ++j) {
        if (j > 1 && p[j - 1] == '*') {
            //0次，多次且前面都已匹配
            dp[i][j] = dp[i][j - 2] || (i > 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.') && dp[i - 1][j]);
        } else {
            //当前值相同且前面都已匹配
            dp[i][j] = i > 0 && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
        }
    }
}
return dp[m][n];
```

- 矩阵的最小路径和
```cpp
//先对首行处理
for(int j=1;j<n;j++){
    dp[0][j]=dp[0][j-1]+grid[0][j];
}
for(int i=1;i<m;i++){
    for(int j=0;j<n;j++){
        if(j>0){
            dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];
        }else{
            dp[i][j]=dp[i-1][j]+grid[i][j];
        }
    }
}
```

- 计算器
初始op为+，保存连续的两个运算符op,c：先结算op；然后判断当c是+-时将中间结果累加到res。
```cpp
char op = '+';
for(int i0;i<n;i++){
    char c=s[i];
    if(c>='0' && c<='9'){
        num=num*10+c-'0';
    }
    if (c == '+' || c == '-' || c == '*' || c == '/' || i == n - 1){
        //计算中间结果
        switch(op):{
            case '+': curRes += num; break;
            case '-': curRes -= num; break;
            case '*': curRes *= num; break;
            case '/': curRes /= num; break;
        }
        //结算本次运算符
        if (c == '+' || c == '-' || i == n - 1) {
            res += curRes;
            curRes = 0;
        }
        //保存本次运算符
        op = c;
        num = 0;
    }
return res;
```