<!-- TOC -->

- [图](#图)
  - [图的遍历BFS](#图的遍历bfs)
  - [最小生成树（边权重最小）](#最小生成树边权重最小)
    - [K算法-O(ElogE)](#k算法-oeloge)
    - [Prim算法](#prim算法)
  - [图-最短路径（变权重最小）](#图-最短路径变权重最小)
    - [Dijkstra（迪克斯特拉）算法：带权重单源最短路径问题 (单源，非负)](#dijkstra迪克斯特拉算法带权重单源最短路径问题-单源非负)
    - [Floyd算法：图中所有节点的最短路径 (全局)](#floyd算法图中所有节点的最短路径-全局)
      - [最短路径](#最短路径)
  - [图题目](#图题目)
    - [最少换乘次数 BFS](#最少换乘次数-bfs)
    - [克隆图 BFS，Map<old,new>](#克隆图-bfsmapoldnew)
    - [课程表：是否可以完成所有课程学完(在有向图中检测是否有环BFS遍历完，所有入度都为0)](#课程表是否可以完成所有课程学完在有向图中检测是否有环bfs遍历完所有入度都为0)
    - [图的关键节点](#图的关键节点)

<!-- /TOC -->

<a id="markdown-图" name="图"></a>
# 图
主要是针对D算法，F算法。
>>G是连通图<<=>>有生成树

---

- 图的表示：**邻接链表，邻接矩阵**
- BFS：能够正确计算最短路径；
- DFS：图的结构；前驱子图构成森林

拓扑排序：有向无环图，在一条水平线展示出来，该水平线上的边都是左指向右。
计算完成时间，先后排序，然后节点连接。

<a id="markdown-图的遍历bfs" name="图的遍历bfs"></a>
## 图的遍历BFS
>>无向图邻接矩阵对称；有向图邻接矩阵非对称；代码一致
```cpp
void bfs(int[][] G,int v){
        set<int>ss;
        queue<int>q;
        q.push(v);
        ss.insert(v);
        while(!q.empty()){
            int node=q.front();q.pop();
            cout<<node;
            for(int n : G[node]){
                if(!ss.count(n))
                    ss.insert(n);
                    q.push(n);
            }
        }
}
```

<a id="markdown-最小生成树边权重最小" name="最小生成树边权重最小"></a>
## 最小生成树（边权重最小）
无环子集T，将所有节点连接，边权重最小。这样的图T称为 最小生成树。

<a id="markdown-k算法-oeloge" name="k算法-oeloge"></a>
### K算法-O(ElogE)
贪心算法，**选择权重最小边加入森林**

---
```cpp
struct edge{int u,v,cost;};
bool cmp(edge &e1,const edge &e2){
    return e1.cost < e2.cost;
}
edge es[MAX_E];  
int V,E;   //顶点数和边数
int kruskal(){
    sort(es,es+E,cmp);       //按照edge.cost的顺序从小到大排列
    init_union_find(V);      //并查集的初始化
    int res=0;
    for(int i=0; i<E; i++){
        edge e=es[i];
        if(!same(e.u,e.v)){
            unite(e.u,e.v);
            res+=e.cost;
        }
    }
    return res;
}
```
>>…………………………………前方高能……………………………………

<a id="markdown-prim算法" name="prim算法"></a>
### Prim算法
[图解Prim算法](https://www.cnblogs.com/alantu2018/p/8464561.html)
![avatar](https://images0.cnblogs.com/blog/578455/201311/13160613-3ad1c17637974add96fb9358ed705677.png)
![avatar](https://images0.cnblogs.com/blog/578455/201311/13160620-fa572448a533462e9ac7c1731d1b507e.png)

---
>>选择最小边
```cpp
vis//标记是否遍历过
dis//节点值
mp[i][j]//节点i,j间的边权重和
void prim(){
    memset(vis,0,sizeof(vis));
    memset(dis,INF,sizeof(dis)); 
    dis[1]=0;
    ans=0;
    dis[0]=INF;
    while(true){
        //初始化，选择权值最小的边
        int m=0;
        for(int i=1; i<=n; i++){
            if(!vis[i] && dis[i]<dis[m])
                m=i;
        }
        if(m==0)
            break;
        vis[m]=1;        //选择后标记
        ans+=dis[m];     //累加权重
        for(int i=1; i<=n; i++)
            dis[i]=min(dis[i],mp[m][i]);//更新连接的边权，否则INF
    }
}
```

<a id="markdown-图-最短路径变权重最小" name="图-最短路径变权重最小"></a>
## 图-最短路径（变权重最小）

<a id="markdown-dijkstra迪克斯特拉算法带权重单源最短路径问题--单源非负" name="dijkstra迪克斯特拉算法带权重单源最短路径问题--单源非负"></a>
### Dijkstra（迪克斯特拉）算法：带权重单源最短路径问题  (单源，非负)
时间复杂度为O(V^2+E) ; 所有边权重非负。
![avatar](https://pic002.cnblogs.com/images/2012/426620/2012073019540660.gif)

```cpp
struct edge{
    int to;
    int cost;//对节点编号和权值
    };//图的边
typedef pair<int,int> P;//first为最短距离，second为相应顶点
int V;
vector<vector<edge>> G[MAX_V];
int d[MAX_V];
void dijkstra(int s){
    priority_queue<P,vector<P>,greater<P>> q;//最小堆
    fill(d,d+V,INF);//各点value全部设为INF
    d[s]=0;//起始点为0
    q.push(P(0,s));
    while(!q.empty()){
        P p=q.top(); q.pop();
        int v=p.second;
        for(int i=0;i<G[v].size();i++){
            edge e=G[v][i];
            //节点v，边e，下一节点e->to
            if(d[e.to]>d[v]+e->cost){
                d[e.to]=d[v]+e->cost;
                que.push(P(d[e.to],e->to));
            }
        }
    }
}
```

<a id="markdown-floyd算法图中所有节点的最短路径-全局" name="floyd算法图中所有节点的最短路径-全局"></a>
### Floyd算法：图中所有节点的最短路径 (全局)
时间复杂度 O(V^3)；所有边权重可负，但环路不可负；
可以用于无向图和有向图中。也可以用于负权的最短路径问题（虽然复杂度会比较高）。Floyd算法的时间复杂度为O（n^3），空间复杂度为O（n^2）。

![avatar](img/F.png)
```cpp
// 弗洛伊德算法实现
//D：用来计算每个相邻点的距离，也就是我们的已知条件；
//P：用来表示中间点k的代数。比如说P中p[i,j]的值就是i与j两点的中间点代数。
void ShortestPath_Floyd(int** p, int** D){
    int v = 0, w = 0, k = 0;
    // 初始化数据
    for (v = 0; v < nVer; ++v){
        for (w = 0; w < nVer; ++w){
            D[v][w] = Edges[v][w];//v-w间的边
            p[v][w] = w;//v-w路径v的下一节点w
        }
    }
    //把K为中间节点
    for (k = 0; k < nVer; ++k){
        for (v = 0; v < nVer; ++v){
            for(w = 0; w < nVer; ++w){
                if (D[v][w] > D[v][k] + D[k][w]){
                    D[v][w] = D[v][k] + D[k][w];
                    p[v][w] = p[v][k];
                }
            }
        }
    }
}

```
<a id="markdown-最短路径" name="最短路径"></a>
#### 最短路径
- D算法：单源、权值不可负、有向/无向（自环）
- F算法：全局、权值可负但环路不可负、有向/无向（自环）


<a id="markdown-图题目" name="图题目"></a>
## 图题目

<a id="markdown-最少换乘次数-bfs" name="最少换乘次数-bfs"></a>
### 最少换乘次数 BFS
n个城市，部分城市之间有单向航道，给定起始点，得到各个城市的最少换乘次数

```cpp
typedef struct{
    int id;     //城市的id
    int count;//该城市到其他城市的道路数目
    int des[LEN];//到的其他城市
}City;

City city[LEN];queue<City>q;int ans[LEN];bool vis[LEN];

void bfs(int v){
    int num=0;
    vis[v]=1;
    //将起点v指向的第一层目的地压入队列,城市v：city[v]
    for(int i=0;i< city[v].count;i++){
        vis[city[v]->des[i]]=1;
        q.push(city[city[v].des[i]]);
    }
    while(!q.empty()){
        num++;
        int q_size=q.size();
        for(int i=0;i< q_size;i++){
            int tmp=q.front().id;q.pop();
            ans[tmp]=num;
            for(int j=0;j<city[tmp].count;j++){
                if(!vis[city[tmp]->des[j]]){
                    vis[city[tmp]->des[j]]=1;
                    q.push(city[city[tmp]->des[j]]);
                }
            }
        }
    }
}
```

<a id="markdown-克隆图-bfsmapoldnew" name="克隆图-bfsmapoldnew"></a>
### 克隆图 BFS，Map<old,new>
```cpp
Node* cloneGraph(Node* node) {
    unordered_map<Node*, Node*> m;
    queue<Node*> q{{node}};
    Node *clone = new Node(node->val);
    m[node] = clone;
    while (!q.empty()) {
        Node *t = q.front(); q.pop();
        for (Node *neighbor : t->neighbors) {
            if (!m.count(neighbor)) {
                m[neighbor] = new Node(neighbor->val);
                q.push(neighbor);
            }
            m[t]->neighbors.push_back(m[neighbor]);
        }
    }
    return clone;
}
```

<a id="markdown-课程表是否可以完成所有课程学完在有向图中检测是否有环bfs遍历完所有入度都为0" name="课程表是否可以完成所有课程学完在有向图中检测是否有环bfs遍历完所有入度都为0"></a>
### 课程表：是否可以完成所有课程学完(在有向图中检测是否有环BFS遍历完，所有入度都为0)
>>一系列[0,1]学0前必须先学1->0；路径题目，是否能够全部学完。
```cpp
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> graph(numCourses, vector<int>());
    vector<int> in(numCourses);
	//统计入度；构造邻接矩阵
    for (auto a : prerequisites) {
        graph[a[1]].push_back(a[0]);
		++in[a[0]];
    }
    queue<int> q;
	//根据入度寻找入口
    for (int i = 0; i < numCourses; ++i) {
        if (in[i] == 0)
            q.push(i);
    }
    while (!q.empty()) {
        int t = q.front(); q.pop();
        //res.push_back(t);//保留课程顺序
        for (auto a : graph[t]) {
            --in[a];
            if (in[a] == 0)//入度为0时入队列，否则重复
                q.push(a);
        }
    }
    //返回是否能够上完
    for (int i = 0; i < numCourses; ++i) {
        if (in[i] != 0)
            return false;
    }
    return true;
    
    //返回可能的上课顺序
    if (res.size() != numCourses)
        res.clear();
    return res;
}
```

<a id="markdown-图的关键节点" name="图的关键节点"></a>
### 图的关键节点
>>通过判断下一层节点node的入度是否为0确定node的前驱是否已经全部累加到此节点；如已全部累加则不再入队列，否则重复节点重复往后累加错误
```cpp
vector<int>BFS(Node* root){
    vector<Node*>res;
    queue<Node*>q{root};

    while(!q.empty()){
        Node* node=q.top();q.pop();
        if(node->val==root->val){
            res.push_back(node);
        }
        for(Node* n:node->next){
            n->val+=(node->val/(node->next.size()));
            n->in--;
            if(n->in==0)
                q.push(n);
    }
    return res;
}
```
>>………………………………………警报解除…………………………………………


```
   > b
  /  |>  \>
a -> d -> e
  \>
    c
```

