# 图
主要是针对D算法，F算法。
>>G是连通图<<=>>有生成树

---

- 图的表示：**邻接链表，邻接矩阵**
- BFS：能够正确计算最短路径；
- DFS：图的结构；前驱子图构成森林

拓扑排序：有向无环图，在一条水平线展示出来，该水平线上的边都是左指向右。
计算完成时间，先后排序，然后节点连接。

## 最小生成树（边权重最小）
无环子集T，将所有节点连接，边权重最小。这样的图T称为 最小生成树。

### K算法-O(ElogE)
贪心算法，**选择权重最小边加入森林**

---
```cpp
struct edge{int u,v,cost;};
bool cmp(edge &e1,const edge &e2){
    return e1.cost < e2.cost;
}
edge es[MAX_E];  
int V,E;   //顶点数和边数
int kruskal(){
    sort(es,es+E,cmp);       //按照edge.cost的顺序从小到大排列
    init_union_find(V);      //并查集的初始化
    int res=0;
    for(int i=0; i<E; i++){
        edge e=es[i];
        if(!same(e.u,e.v)){
            unite(e.u,e.v);
            res+=e.cost;
        }
    }
    return res;
}
```
>>…………………………………前方高能……………………………………

### Prim算法
[图解Prim算法](https://www.cnblogs.com/alantu2018/p/8464561.html)
![avatar](https://images0.cnblogs.com/blog/578455/201311/13160613-3ad1c17637974add96fb9358ed705677.png)
![avatar](https://images0.cnblogs.com/blog/578455/201311/13160620-fa572448a533462e9ac7c1731d1b507e.png)

---
>>选边
```cpp
vis//标记是否遍历过
dis//节点值
mp[i][j]//节点i,j间的边权重和
void prim(){
    memset(vis,0,sizeof(vis));
    memset(dis,INF,sizeof(dis)); 
    dis[1]=0;
    ans=0;
    dis[0]=INF;
    while(true){
        //初始化，选择权值最小的边
        int m=0;
        for(int i=1; i<=n; i++){
            if(!vis[i] && dis[i]<dis[m])
                m=i;
        }
        if(m==0)
            break;
        vis[m]=1;        //选择后标记
        ans+=dis[m];     //累加权重
        for(int i=1; i<=n; i++)
            dis[i]=min(dis[i],mp[m][i]);//更新连接的边权，否则INF
    }
}
```

## 图-最短路径（变权重最小）

### Dijkstra（迪克斯特拉）算法：带权重单源最短路径问题  (单源，非负)
时间复杂度为O(V^2+E) ; 所有边权重非负。
![avatar](https://pic002.cnblogs.com/images/2012/426620/2012073019540660.gif)

```cpp
struct edge{
    int to, cost;//对节点编号和权值
    };//图的边
typedef pair<int,int> P;//保存的结果，first为最短距离，second为相应顶点
int V;
vector<vector<edge>> G[MAX_V];
int d[MAX_V];
void dijkstra(int s){
    priority_queue<P,vector<P>,greater<P>> que;//小堆
    fill(d,d+V,INF);//各点value全部设为INF
    d[s]=0;//起始点为0
    que.push(P(0,s));
    while(!que.empty()){
        P p=que.top(); que.pop();
        int v=p.second;
        //遍历该点的边
        for(int i=0;i<G[v].size;i++){
            edge e=G[v][i];
            //v通过边e到达e.to节点，权值松弛操作
            if(d[e.to]>d[v]+e.cost){
                d[e.to]=d[v]+e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}
```

### Floyd算法：图中所有节点的最短路径 (全局)
时间复杂度 O(V^3)；所有边权重可负，但环路不可负；
可以用于无向图和有向图中。也可以用于负权的最短路径问题（虽然复杂度会比较高）。Floyd算法的时间复杂度为O（n^3），空间复杂度为O（n^2）。

![avatar](img/F.png)
```cpp
// 弗洛伊德算法实现
//D：用来计算每个相邻点的距离，也就是我们的已知条件；
//P：用来表示中间点k的代数。比如说P中p[i,j]的值就是i与j两点的中间点代数。
void ShortestPath_Floyd(int** p, int** D){
    int v = 0, w = 0, k = 0;
    // 初始化数据
    for (v = 0; v < nVer; ++v){
        for (w = 0; w < nVer; ++w){
            D[v][w] = Edges[v][w];//v-w间的边
            p[v][w] = w;//v-w路径v的下一节点w
        }
    }
    //把K为中间节点
    for (k = 0; k < nVer; ++k){
        for (v = 0; v < nVer; ++v){
            for(w = 0; w < nVer; ++w){
                if (D[v][w] > D[v][k] + D[k][w]){
                    D[v][w] = D[v][k] + D[k][w];
                    p[v][w] = p[v][k];
                }
            }
        }
    }
}

```
#### 最短路径
- D算法：单源、权值不可负、有向/无向（自环）
- F算法：全局、权值可负但环路不可负、有向/无向（自环）



## 图题目

- 1、最少换乘次数 BFS
n个城市，部分城市之间有单向航道，给定起始点，得到各个城市的最少换乘次数

```cpp
typedef struct{
    int id;     //城市的id
    int count;//该城市到其他城市的道路数目
    int des[LEN];//到的其他城市
}City;
City city[LEN];
queue<City>q; //队列
int ans[LEN];  //结果
bool vis[LEN];//记录有没有访问过
int n;
void bfs(int v){
    int num=0;
    vis[v]=1;
    for(int i=0;i<city[v].count;i++){ //将起点v指向的目的地压入队列
        vis[city[v].des[i]]=1;
        q.push(city[city[v].des[i]]);
    }
    while(!q.empty()){   //当队列非空时
        num++;   //代表bfs的深度,到当前城市的换乘次数，BFS层次遍历这一层结果是一样的
        for(int i=0;i<q_size();i++){//该层可到达的目的地
            int tmp=q.front().id;q.pop();
            ans[tmp]=num;//保留到达此地的换乘次数
			//将此地的下一层目的地push到Q
            for(int j=0;j<city[tmp].count;j++){
                if(!vis[city[tmp].des[j]]){
                    vis[city[tmp].des[j]]=1;
                    q.push(city[city[tmp].des[j]]);
                }
            }
        }
    }
}
```

- 2、克隆图 BFS，Map<old,new>
```cpp
Node* cloneGraph(Node* node) {
    unordered_map<Node*, Node*> m;
    queue<Node*> q{{node}};
    Node *clone = new Node(node->val);
    m[node] = clone;
    while (!q.empty()) {
        Node *t = q.front(); q.pop();
        //取当前节点，克隆其邻居(if该邻居还未克隆)，后补充邻居
        for (Node *neighbor : t->neighbors) {
            if (!m.count(neighbor)) {
                m[neighbor] = new Node(neighbor->val);
                q.push(neighbor);
            }
            m[t]->neighbors.push_back(m[neighbor]);
        }
    }
    return clone;
}
```

- 3、课程表：是否可以完成所有课程学完(在有向图中检测是否有环BFS遍历完，所有入度都为0)
>>一系列[0,1]学0前必须先学1->0；路径题目，是否能够全部学完。
```cpp
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> graph(numCourses, vector<int>());
    vector<int> in(numCourses);
	//统计入度；构造邻接矩阵
    for (auto a : prerequisites) {
        graph[a[1]].push_back(a[0]);
		++in[a[0]];
    }
    queue<int> q;
	//根据入度寻找入口
    for (int i = 0; i < numCourses; ++i) {
        if (in[i] == 0)
            q.push(i);
    }
    while (!q.empty()) {
        int t = q.front(); q.pop();
        //res.push_back(t);//保留课程顺序
        for (auto a : graph[t]) {
            --in[a];
            if (in[a] == 0)
                q.push(a);
        }
    }
    //返回是否能够上完
    for (int i = 0; i < numCourses; ++i) {
        if (in[i] != 0)
            return false;
    }
    return true;
    
    //返回可能的上课顺序
    if (res.size() != numCourses)
        res.clear();
    return res;
}
```

- 图的关键节点
```cpp
vector<int>BFS(Node* root){
    vector<Node*>res;
    queue<Node*>q{root};

    while(!q.empty()){
        Node* node=q.top();q.pop();
        if(node->val==root->val){
            res.push_back(node);
        }
        //仅把值累加到下一层节点即可;通过判断下一层节点入度是否为0确定前驱是否已经全部累加到此节点，如已全部累加则不再入队列，否则重复节点重复往后累加错误
        for(Node* n:node->next){
            if(n->in==0)
                continue;
            n->val+=(node->val/(node->next.size()));
            n->in--;
            q.push(n);  
    }
    return res;
}
```
>>………………………………………警报解除…………………………………………


```
    >b
  /  |>  \>
a -> d -> e
  \>
    c
```

