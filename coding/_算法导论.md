<a id="markdown-算法导论" name="算法导论"></a>
# 算法导论

<!-- TOC -->

1. [算法导论](#算法导论)
   1. [动态规划](#动态规划)
      1. [钢条切割问题](#钢条切割问题)
      2. [最小的k个数](#最小的k个数)

<!-- /TOC -->

<a id="markdown-动态规划" name="动态规划"></a>
## 动态规划

- 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的。
- 无后效性。即子问题的解一旦确定，不受之后和包含它的更大的问题的决策影响。
- 子问题重叠性质。子问题会被重复计算多次。动态规划对每一个子问题只计算一次保存在表格，简化重复计算时。


<a id="markdown-钢条切割问题" name="钢条切割问题"></a>
### 钢条切割问题

长度为n英寸的钢条有$2^{n-1}$种切割方法：因为在距离钢条左端i (i = 1, 2, … , n-1)英寸处，我们总是可以选择切割或不切割。**有重复，可不完全遍历**

子问题：
1. 左端切下长度为$i$的一段，其中i=1, 2, … , n;有n种切法，左端不再切割，该段的销售收益为$P_i$
2. 右端长度为n-i，对这一段再进行切割，这是一个规模更小的子问题，其收益为$r_{n-i}$。\
显然得到最优收益
$$r_n=\max_{1≤i≤n}({p_i+r_{n-i}})$$

```cpp
int cut(int p[],int n){
	if(n==0)
		return 0;
	int q=-1;
	for(int i=1;i<=n;i++)
		q=max(q,p[i]+cut(p,n-i));
	return q;
}
```
>>递归代码的调用树

![avatar](https://img-blog.csdn.net/20180531012005456?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd0emhvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

复杂度分析：显然重复求解。

![avatar](https://img-blog.csdn.net/20180313095857897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfNDExNzA5NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```cpp
int gain[n+1]={0};//长度对应的最大收益
int p[n+1]={0,1,5,,,,};//各种长度价位都有
int BottomUpRod(int n){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++)
            gain[i]=max(gain[i],p[j]+gain[i-j]);//子长度[i-j]最优+价格[j]取最优
    }
    return gain[n];
}
```

<a id="markdown-最小的k个数" name="最小的k个数"></a>
### 最小的k个数

- 全局排序：O(n*log(n))
- 局部排序，只排序TopK个数，冒泡等；O(n*k)
- 堆：TopK个数也不排序了，O(n*log(k))

**TopK的另一个解法：快排**不同在于对返回的下标判断是否够K个即可

```cpp
int partition(vector<int> nums, int start, int end){
    int key = nums[start];
    while (start < end) {
        //从右找小于key的值，赋给start
        while (start < end and nums[end] >= key)
            end --;
        nums[start] = nums[end];
        //从左找大于key的值，赋给end
        while (start < end and nums[start] <= key)
            start ++;
        nums[end] = nums[start];

        //key赋给start
        nums[start] = key;
    }
    return start;
}
//index下标为分割节点，左边index+1个数就是最小的index+1个数
vector<int> GetLeastNumbers(vector<int> input, int k){
    vector<int>output;
    int start = 0;
    int end = input.size() - 1;
    int index = partition(input,start,end);
    while(index != k - 1){
        if(index > k - 1){
            end = index - 1;
            index = partition(input,start,end);
        }
        else{
            start = index + 1;
            index = partition(input,start,end);
        }
    }
    for(int i = 0; i < k; ++i)
        output.push_back(input[i]);
}
```


