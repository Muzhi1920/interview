# DFS+BFS
采用DFS：递归+回溯；BFS：队列

- 克隆图
```cpp
用map保存克隆的对象，以防止死循环
//DFS
递归：
    如果已克隆：
        直接map[node]返回；
    否则克隆当前节点，并map保存；
    遍历当前节点的邻居：
        邻居递归，结果入克隆节点的的邻居栈；
    返回克隆节点；
//BFS
先克隆当前节点m[node]=clone入map；
队列非空：
    取出头结点t
    遍历t的邻居n ：
        if n未克隆:
            克隆m[n]=new Node(n->val);
            n入队列
        m[t]->neighbor.push(m[n])
```
- 单词接龙
```cpp
//BFS
初始化队列
队列非空：
    获取头部单词word
    if word==endWord:
        return res+1;
    遍历word字符：
        首先备份word2
        对word2替换a~z 26 个字符：
            如果当前词word2存在且不等于word：
                word2入队列，词典擦除word2
    res+1 //入队列的几个词是当前有可能转换的几个可能。
如果队列空了，也没结果说明无法完成，故返回0
```
- 岛屿数量
```cpp
res;visited标记
二维遍历：
    如果未标记且是1：
        BFS // DFS  遍历一个岛屿则拓展到边是1个故完毕后+1
        res++;

BFS：
    方向数组；队列Q入初值；标记当前位置；
    while(Q非空):
        获取,pop
        遍历4个方向：
            边界以外：
                continue
            未标记且是1：
                位置入队列；
                标记位置
```

- 朋友圈
通过DFS，将相关的人都标记，标记完作为一个朋友圈，res++;如果不标记会有重复。
```cpp
visit：当前朋友圈是否有此人；res
一维遍历M的各行 人：
    if 该人未标记：
        DFS(i,M,visit);
        res++;
return res

void DFS():
    标记此人
    遍历此人的朋友：
        if 未标记且是朋友：
            DFS(i,M,visit)
```

