# DFS+BFS
采用DFS：递归+回溯；BFS：队列

- 单词接龙
```cpp
//BFS
set(wordList.begin(),wordList.end())
Q{beginWord}
while(!Q.empty())：
    word=Q.top();pop()
    if word==endWord:
        return res+1;
    for(i in word.size){
        bak=word;
        for(char ch:a~z){ //替换26 个字符：
            bak[i]=ch;
            if(set.count(bak) && bak!=word){
               q(bak);
               set.erase(bak);
            }
        }
    }
    res++ //入队列的几个词是当前有可能转换的几个可能。
return 0;
```
- 岛屿数量
```cpp
二维遍历：
    if(mark[i][j]==0 && grid[i][j]=='1'){
        DFS(mark,grid,i,j);
        count++;
}
void DFS(& mark,& grid,int x,int y){
    mark[x][y]=1;
    static const int dx[]={-1,1,0,0};
    static const int dy[]={0,0,-1,1};
    for(int i=0;i<4;i++){
        int x_=x+dx[i];
        int y_=y+dy[i];
        if(x_<0||x_>=mark.size()||y_<0||y_>=mark[x_].size()){
            continue;
        }
        if(mark[x_][y_]==0&&grid[x_][y_]=='1'){
            DFS(mark,grid,x_,y_);
        }
    }
}
```

- 朋友圈
通过DFS，将相关的人都标记，标记完作为一个朋友圈，res++;如果不标记会有重复。
```cpp
int findCircleNum(vector<vector<int>>& M) {
    int n = M.size(), res = 0;
    vector<bool> visited(n, false);
    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (visited[i])
            continue;
        q.push(i);
        while(!q.empty()) {
            int t = q.front(); q.pop();
            visited[t] = true;
            for (int j = 0; j < n; ++j) {
                if (!M[t][j] || visited[j]) continue;
                q.push(j);
            }
        }
        ++res;
    }
    return res;
}
```

