## 一、动态规划
### 1、钢条切割问题
长度为n英寸的钢条有$2^{n-1}$种切割方法：因为在距离钢条左端i (i = 1, 2, … , n-1)英寸处，我们总是可以选择切割或不切割。**有重复，可不完全遍历**

**动态规划的第一个基本特点：所求解的问题满足最优子结构，问题可以分解为规模更小的子问题，问题的最优解依赖于子问题的最优解，并且这些子问题可以独立求解**

子问题：
1. 左端切下长度为$i$的一段，其中i=1, 2, … , n;有n种切法，左端不再切割，该段的销售收益为$P_i$
2. 右端长度为n-i，对这一段再进行切割，这是一个规模更小的子问题，其收益为$r_{n-i}$。\
显然得到最优收益
$$r_n=\max_{1≤i≤n}({p_i+r_{n-i}})$$

```cpp
int CutRod(int p[],int n){
	if(n==0)
		return 0;
	int q=-1;
	for(int i=1;i<=n;i++)
		q=max(q,p[i]+CutRod(p,n-i));
	return q;
}
```
>>递归代码的调用树
![avatar](https://img-blog.csdn.net/20180531012005456?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd0emhvdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

复杂度分析：显然重复求解。

**动态规划的第二个基本特点：相同的子问题只需要求解一次，如果子问题的解会被多次引用，可以将子问题的解保存起来**
![avatar](https://img-blog.csdn.net/20180313095857897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfNDExNzA5NDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
```cpp
int BottomUpRod(int p[],int n){
	int r[n+1]={0};
    int p[n+1]={0,1,5,,,,};//各种长度价位都有
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++)
			r[i]=max(r[i],p[j]+r[i-j]);
	}
	return r[n];
}
```

### 二、最小的k个数
>>4,5,1,6,2,7,3,8  O(k*n)=O(n)
```cpp
int partition(vector<int> nums, int start, int end){
    int key = nums[start];
    while (start < end) {
        while (start < end and nums[end] >= key)
            end -= 1;
        nums[start] = nums[end];
        while (start < end and nums[start] <= key)
            start += 1;
        nums[end] = nums[start];
        nums[start] = key;
    }
    return start;
}

vector<int> GetLeastNumbers(vector<int> input, int k){
    vector<int>output;
    int start = 0;
    int end = input.size() - 1;
    int index = partition(input,start,end);
    while(index != k - 1){
        if(index > k - 1){
            end = index - 1;
            index = partition(input,start,end);
        }
        else{
            start = index + 1;
            index = partition(input,start,end);
        }
    }
    for(int i = 0; i < k; ++i)
        output.push_back(input[i]);
}
```























