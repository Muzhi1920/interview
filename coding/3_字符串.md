<!-- TOC -->

- [字符串](#字符串)
        - [移除K个数字](#移除k个数字)
    - [不固定滑动窗口](#不固定滑动窗口)
    - [不固定窗口问题](#不固定窗口问题)
        - [最长不重复子串](#最长不重复子串)
        - [最小包含T的排列的子串*](#最小包含t的排列的子串)
        - [字符串包含另一子串的排列*](#字符串包含另一子串的排列)
        - [替换K次字符后最长的重复字符构成的子串长度](#替换k次字符后最长的重复字符构成的子串长度)
        - [重复的DNA序列](#重复的dna序列)

<!-- /TOC -->

<a id="markdown-字符串" name="字符串"></a>
# 字符串


<a id="markdown-移除k个数字" name="移除k个数字"></a>
### 移除K个数字

```cpp
string removeKdigits(string num, int k) {
    string res;
    int n = num.size();
    for (char c : num) {
        while (k && res.size() && res.back() > c) {
            res.pop_back();
            --k;
        }
        //前导0
        if (res.size() || c != '0')
            res.push_back(c);
    }
    while (res.size() && k--)
        res.pop_back();
    return res.empty() ? "0" : res;
}

```




<a id="markdown-不固定滑动窗口" name="不固定滑动窗口"></a>
## 不固定滑动窗口
<a id="markdown-不固定窗口问题" name="不固定窗口问题"></a>
## 不固定窗口问题

<a id="markdown-最长不重复子串" name="最长不重复子串"></a>
### 最长不重复子串
Q1：当有重复的时候左更新；不重复的时候窗口长度累加。所以O(N)的遍历即可

```cpp
char c[26]=-1,left=-1;
for(int i=0;i<s.length();i++){
    left=max(c[nums[i]-'a'],left]); //不是-1则重复
    res=max(res,i-left);
    c[nums[i]-'a']=i;
}
return res;
```

<a id="markdown-最小包含t的排列的子串" name="最小包含t的排列的子串"></a>
### 最小包含T的排列的子串*
>>包含其他字符
```cpp
s,t
char c[126]=0;//对t遍历统计c各字符次数
for(int i=0;i<s.length();i++){
    c[s[i]]--;
    if c[s[i]]>=0：//说明属于子串t的字符
        cnt++;
    while(cnt==t.size()){ //子串可构成t；然后左侧右移取最小窗口
        minLen=min(minLen,i-left+1);
        res=res.substr(left,minLen);
        c[s[left]]++; //从左往右不相关加上
        if(c[s[left]]>0) //如果加的是相关字符则跳出
            cnt--;
        left++;
    }
}
return res;
```

<a id="markdown-字符串包含另一子串的排列" name="字符串包含另一子串的排列"></a>
### 字符串包含另一子串的排列*
>>不包含其他字符
```cpp
for(auto c :t)
    m[c]++;//保存t中字符次数
for(int i=0;i< s.length();i++){
    m[s[i]]--;
    if(m[s[i]]<0){ //说明此时没匹配对
        while(++m[left]!=0) //则对之前匹配对的再补上+1
            left++;
    }
    else{ 
        if (i-left+1==t.size())//窗口大小==t长度相同
            return true;
    }
}
return t.szie()==0;
```

<a id="markdown-替换k次字符后最长的重复字符构成的子串长度" name="替换k次字符后最长的重复字符构成的子串长度"></a>
### 替换K次字符后最长的重复字符构成的子串长度
```cpp
int count,res,left=0;
map<char,int>m;
for(int i=0;i< s.length();i++){
    m[s[i]]++;
    count=max(count,m[s[i]]);
    while(i-left+1 > (count+k)) //达到了最大长度，左边界右移
        m[s[left]--;
        left++;
    res=max(res,i-left+1);
}
```

<a id="markdown-重复的dna序列" name="重复的dna序列"></a>
### 重复的DNA序列
```python
def findRepeatedDnaSequences(self, s: str) -> List[str]:
    from collections import defaultdict
    visited = set()
    res = set()
    for i in range(0, len(s) - 9):
        tmp = s[i:i+10]
        if tmp in visited:
            res.add(tmp)
        visited.add(tmp)
    return list(res)
```

