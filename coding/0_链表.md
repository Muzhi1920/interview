<a id="markdown-链表" name="链表"></a>
# 链表
较复杂的为链表的重排，排序
重排的链表：有的需要dummy辅助头指针，返回dummy->next

---

<!-- TOC -->

- [链表](#链表)
    - [复杂链表深拷贝](#复杂链表深拷贝)
    - [链表交换](#链表交换)
        - [链表两两逆序](#链表两两逆序)
        - [链表逆序，K个一组](#链表逆序k个一组)
        - [链表重排](#链表重排)
    - [链表排序](#链表排序)
        - [链表插入排序](#链表插入排序)
        - [链表归并排序](#链表归并排序)
    - [删除链表连续重复元素](#删除链表连续重复元素)
    - [大招：树与链表](#大招树与链表)
        - [链表转二叉平衡树（特殊：有序链表转二叉平衡排序树）](#链表转二叉平衡树特殊有序链表转二叉平衡排序树)
        - [二叉树转链表（特殊：二叉排序树转有序链表[中序实现]）](#二叉树转链表特殊二叉排序树转有序链表中序实现)

<!-- /TOC -->


<a id="markdown-复杂链表深拷贝" name="复杂链表深拷贝"></a>
## 复杂链表深拷贝

```cpp
//节点入列表
//map保存节点位置,同列表索引
//列表前后连接并且连接随机指针

```


<a id="markdown-链表交换" name="链表交换"></a>
## 链表交换

<a id="markdown-链表两两逆序" name="链表两两逆序"></a>
### 链表两两逆序

>>从前往后两个交换，两个交换
```cpp
ListNode* fun():
    if(!head or !head->next)：
        return head；
    Pn=head->next;
    head->next=fun(head->next->next);
    Pn->next=head;
    return Pn;
```

<a id="markdown-链表逆序k个一组" name="链表逆序k个一组"></a>
### 链表逆序，K个一组
```cpp
ListNode* reverse(head,tail) {
    ListNode *pre = tail;
    while (head != tail) {
        ListNode *t = head->next;
        head->next = pre;
        pre = head;
        head = t;
    }
    return pre;
}
ListNode* reverseKGroup(head, int k) {
    ListNode *cur = head;
    for (int i = 0; i < k; ++i) {
        if (!cur) 
            return head;
        cur = cur->next;
    }
    ListNode *new_head = reverse(head, cur);
    head->next = reverseKGroup(cur, k);
    return new_head;
}
```

<a id="markdown-链表重排" name="链表重排"></a>
### 链表重排
1->2->3->4->5 \
1->5->2->4->3 将后一半翻转交替插入\
method_1：快慢指针将后面断开，且翻转，然后依次连接插入；
method_2
```cpp
//遍历节点入栈，且得到链接cnt=(size-1)/2
cur=head;
while(cnt-- >0){
    t=s.top();s.pop();
    Pn=cur->next;
    cur->next=t;t->next=Pn;  //完成插入节点操作
    cur=Pn;  //指向原来的下一个节点
}
s.top()->next=NULL;
```

<a id="markdown-链表排序" name="链表排序"></a>
## 链表排序

<a id="markdown-链表插入排序" name="链表插入排序"></a>
### 链表插入排序

>>遍历head链表，在cur中找到比当前较大节点插入到dummy中
```cpp
cur=dummy=node(-1); //辅助接点方便从头插入
while(head):
    Pn=head->next;//保存下一节点

    cur=dummy;//从头寻找head值的插入位置
    while(cur->next && cur->next->val < head->val):
        cur=cur->next;

    head->next=cur->next;
    cur->next=head;//插入

    head=Pn;//更新head
return dummy->next;
```

<a id="markdown-链表归并排序" name="链表归并排序"></a>
### 链表归并排序
```cpp
//连接两个有序链表
ListNode* merge(ListNode* l1, ListNode* l2) {
    if (!l1) return l2;
    if (!l2) return l1;
    if (l1->val < l2->val) {
        l1->next = merge(l1->next, l2);
        return l1;
    } else {
        l2->next = merge(l1, l2->next);
        return l2;
    }
}
//中分head和slow链表至节点，再自底向上去merge
ListNode* sortList(ListNode* head) {
    while(fast && fast->next){
        pre=slow;
        slow=slow->next;
        fast=fast->next->next;
    }
    pre->next=NULL;
    return merge(sortList(head), sortList(slow));
}
```


<a id="markdown-删除链表连续重复元素" name="删除链表连续重复元素"></a>
## 删除链表连续重复元素
>>快慢指针，快指针负责相同则继续后移；判断二者是否为前后关系即可
```cpp
dummy=pre=Node(-1);
pre->next=head //辅助指针
while(head){
    cur=pre->next;
    while(cur->next && cur->val==cur->next->val)
        cur=cur->next;

    if(cur=pre->next)//如果无重复，则后移；否则前后连接
        pre=pre->next;
    else
        pre->next=cur->next;
}
return dummy->next;
```


<a id="markdown-大招树与链表" name="大招树与链表"></a>
## 大招：树与链表
1. 链表转二叉树：一般需要转换，则就是唯一的结果，此时就需要树是高度平衡的，链表也好数组也好（线性表即可）。就需要**快慢指针分成两段，中间为根节点**
2. 二叉树转链表：先序中序后续遍历连接链表即可
3. 较为容易的二叉搜索树与有序链表。树转链表：中序遍历（非递归）；链表转树：快慢指针中间为根。


<a id="markdown-链表转二叉平衡树特殊有序链表转二叉平衡排序树" name="链表转二叉平衡树特殊有序链表转二叉平衡排序树"></a>
### 链表转二叉平衡树（特殊：有序链表转二叉平衡排序树）
>>移动到中间，构建节点，左右分别继续递归构建
```cpp
tail=NUll;
TreeNode* fun(head,tail){
    while(fast!=tail && fast->next!=tail){
        slow=slow->next;
        fast=fast->next->next;
    }
    t=TreeNode(slow);
    t->left=fun(head,slow);
    t->right=fun(slow->next,tail);
    return t;
}
```

<a id="markdown-二叉树转链表特殊二叉排序树转有序链表中序实现" name="二叉树转链表特殊二叉排序树转有序链表中序实现"></a>
### 二叉树转链表（特殊：二叉排序树转有序链表[中序实现]）
>>右指针实现
```cpp
TreeNode *head,*tail = NULL;
void fun(TreeNode *root){
    if(!root)
        return;
    fun(root->left);//至左

    root->left = tail;
    if (tail == NULL) //左右连接
        tail = head = root;
    else
        tail->right = root;

    tail = root;
    fun(root->right);//至右
}
```