# 链表
较复杂的为链表的重排，排序
重排的链表：有的需要dummy辅助头指针，返回dummy->next

---
- 复杂链表深拷贝
```cpp
//节点入列表
//map保存节点位置
//列表前后连接并且连接随机指针

```
- 两两交换链表

从前往后两个交换，两个交换
```cpp
ListNode* fun():
    if(!head or !head->next)：
        return head；
    Pn=head->next; //保存下一节点
    head->next=fun(head->next->next);
    Pn->next=head;
    return Pn;
```

- 链表重排

1->2->3->4->5 ||| 1->5->2->4->3 将后一半翻转交替插入 method_1：快慢指针将后面断开，且翻转，然后依次连接插入；
method_2
```cpp
//遍历节点入栈，且得到链接cnt=(size-1)/2
cur=head;
while(cnt-- >0){
    t=s.top();s.pop();
    Pn=cur->next;//保存下一节点；
    cur->next=t;t->next=Pn;  //完成插入节点操作
    cur=Pn;  //指向原来的下一个节点
    }
s.top()->next=NULL;
```

- 链表插入排序

遍历head链表，在cur中找到比当前较大节点往前插入
```cpp
cur=dummy=node(-1); //辅助接点方便从头插入
while(head):
    Pn=head->next;
    cur=dummy;
    while()： // 遍历dummy寻找比head大的
        cur=cur->next；
    head->next=cur->next;cur->next=head；//插入
    head=Pn；
return dummy->next;
```

- 链表归并排序
```cpp
    ListNode* sortList(ListNode* head) {
        while(fast and fast->next){
            pre=slow;
            slow=slow->next;
            fast=fast->next->next;
        }
        pre->next=NULL;  //断开,head链表和slow链表
        return merge(sortList(head), sortList(slow));//最终分成元素
    }
    //递归连接两个子链表
    ListNode* merge(ListNode* l1, ListNode* l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        if (l1->val < l2->val) {
            l1->next = merge(l1->next, l2);
            return l1;
        } else {
            l2->next = merge(l1, l2->next);
            return l2;
        }
    }
```

- 删除链表重复元素

快慢指针，快指针负责相同则继续后移；判断二者是否为前后关系即可
```cpp
dummy(-1)->next=head //辅助指针
while(head){
    cur=pre->next;

    while(cur->next && cur->val==cur->next->val){
        cur=cur->next;
    }

    if(cur=pre->next){
        pre=pre->next;
    }else{
        pre->next=cur->next;
    }
}
return dummy->next;
```

## 大招：树与链表
1. 链表转二叉树：一般需要转换，则就是唯一的结果，此时就需要树是高度平衡的，链表也好数组也好（线性表即可）。**快慢指针分成两段，中间为根节点**
2. 二叉树转链表：先序中序后续遍历连接链表即可
3. 特别的便是较为容易的二叉搜索树与有序链表。树转链表：中序遍历（非递归）；链表转树：快慢指针中间为根。


- 有序链表转二叉排序树
```cpp
//定义递归 fun(head,tail=NUll)
TreeNode* fun(){
    while(!fast && !fast->next){
        slow=slow->next;
        fast=fast->next->next;
    }
    t=TreeNode(slow);
    t->left=fun(head,slow);  //slow作为尾部不可到达
    t->right=fun(slow->next,tail);

    return t;
}

```

- 二叉排序树转有序列表

非递归实现二叉树的中序遍历
```cpp
Node *head = NULL, *pre = NULL;
stack<Node*> s;
while (root || !st.empty()) {
    while (root) {
        s.push(root);
        root = root->left;
    }
    root = s.top(); s.pop();
    if (!head) 
         head = root;
    if (pre) {    //pre为left root为根 next为right
        pre->right = root;
        root->left = pre;
    }
    pre = root;
    root = root->right;
}
head->left = pre;
pre->right = head;
return head;
```


