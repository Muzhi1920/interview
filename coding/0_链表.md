<!-- TOC -->

- [链表](#链表)
  - [复杂链表深拷贝](#复杂链表深拷贝)
  - [链表交换](#链表交换)
    - [链表两两节点交换](#链表两两节点交换)
    - [链表重排](#链表重排)
  - [链表排序](#链表排序)
    - [链表插入排序](#链表插入排序)
    - [链表归并排序](#链表归并排序)
  - [删除链表重复元素](#删除链表重复元素)
  - [大招：树与链表](#大招树与链表)
    - [有序链表转二叉平衡排序树](#有序链表转二叉平衡排序树)
    - [二叉排序树转有序链表](#二叉排序树转有序链表)

<!-- /TOC -->


<a id="markdown-链表" name="链表"></a>
# 链表
较复杂的为链表的重排，排序
重排的链表：有的需要dummy辅助头指针，返回dummy->next

---


<a id="markdown-复杂链表深拷贝" name="复杂链表深拷贝"></a>
## 复杂链表深拷贝

```cpp
//节点入列表
//map保存节点位置
//列表前后连接并且连接随机指针

```


<a id="markdown-链表交换" name="链表交换"></a>
## 链表交换

<a id="markdown-链表两两节点交换" name="链表两两节点交换"></a>
### 链表两两节点交换

从前往后两个交换，两个交换
```cpp
ListNode* fun():
    if(!head or !head->next)：
        return head；
    Pn=head->next;
    head->next=fun(head->next->next);
    Pn->next=head;
    return Pn;
```


<a id="markdown-链表重排" name="链表重排"></a>
### 链表重排
1->2->3->4->5 ||| 1->5->2->4->3 将后一半翻转交替插入 method_1：快慢指针将后面断开，且翻转，然后依次连接插入；
method_2
```cpp
//遍历节点入栈，且得到链接cnt=(size-1)/2
cur=head;
while(cnt-- >0){
    t=s.top();s.pop();
    Pn=cur->next;//保存下一节点；
    cur->next=t;t->next=Pn;  //完成插入节点操作
    cur=Pn;  //指向原来的下一个节点
    }
s.top()->next=NULL;
```


<a id="markdown-链表排序" name="链表排序"></a>
## 链表排序

<a id="markdown-链表插入排序" name="链表插入排序"></a>
### 链表插入排序
遍历head链表，在cur中找到比当前较大节点往前插入
```cpp
cur=dummy=node(-1); //辅助接点方便从头插入
while(head):
    Pn=head->next;//保存下一节点

    cur=dummy;//从头寻找head值的插入位置
    while(cur->next && cur->next->val < head->val):
        cur=cur->next;

    head->next=cur->next;cur->next=head;//插入

    head=Pn;//更新head
return dummy->next;
```



<a id="markdown-链表归并排序" name="链表归并排序"></a>
### 链表归并排序
```cpp
    ListNode* sortList(ListNode* head) {
        while(fast && fast->next){
            pre=slow;
            slow=slow->next;
            fast=fast->next->next;
        }
        pre->next=NULL;  //中分head链表和slow链表
        return merge(sortList(head), sortList(slow));//最终分成元素
    }
    //递归连接两个子链表
    ListNode* merge(ListNode* l1, ListNode* l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        if (l1->val < l2->val) {
            l1->next = merge(l1->next, l2);
            return l1;
        } else {
            l2->next = merge(l1, l2->next);
            return l2;
        }
    }
```


<a id="markdown-删除链表重复元素" name="删除链表重复元素"></a>
## 删除链表重复元素
快慢指针，快指针负责相同则继续后移；判断二者是否为前后关系即可
```cpp
dummy(-1)->next=head //辅助指针
while(head){
    cur=pre->next;
    while(cur->next && cur->val==cur->next->val){
        cur=cur->next;
    }

    if(cur=pre->next){//如果无重复，则后移
        pre=pre->next;
    }else{
        pre->next=cur->next;//有重复则前后连接
    }
}
return dummy->next;
```


<a id="markdown-大招树与链表" name="大招树与链表"></a>
## 大招：树与链表
1. 链表转二叉树：一般需要转换，则就是唯一的结果，此时就需要树是高度平衡的，链表也好数组也好（线性表即可）。**快慢指针分成两段，中间为根节点**
2. 二叉树转链表：先序中序后续遍历连接链表即可
3. 特别的便是较为容易的二叉搜索树与有序链表。树转链表：中序遍历（非递归）；链表转树：快慢指针中间为根。



<a id="markdown-有序链表转二叉平衡排序树" name="有序链表转二叉平衡排序树"></a>
### 有序链表转二叉平衡排序树
移动到中间，构建节点，左右分别继续递归构建
```cpp
//tail=NUll
TreeNode* fun(head,tail){
    while(fast!=tail && fast->next!=tail){
        slow=slow->next;
        fast=fast->next->next;
    }
    t=TreeNode(slow);
    t->left=fun(head,slow);
    t->right=fun(slow->next,tail);

    return t;
}
```


<a id="markdown-二叉排序树转有序链表" name="二叉排序树转有序链表"></a>
### 二叉排序树转有序链表
```cpp
TreeNode *head = NULL;
TreeNode *tail = NULL;
void fun(TreeNode *root){
	if(!root)
        return;
	fun(root->left);//至左
    //中序
	root->left = tail;
	if (tail == NULL) //左右连接
		tail = head = root;
	else
		tail->right = root;
	tail = root;

	fun(root->right);//至右
}
```