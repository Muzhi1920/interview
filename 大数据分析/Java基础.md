<!-- TOC -->

1. [Java面试基础](#java面试基础)
   1. [JVM与GC](#jvm与gc)
      1. [JVM](#jvm)
      2. [GC](#gc)
         1. [标记-清除](#标记-清除)
         2. [复制算法----适用于新生代](#复制算法----适用于新生代)
         3. [标记-整理----适用于老年代](#标记-整理----适用于老年代)
         4. [分代收集](#分代收集)
      3. [关于内存分配与回收原则](#关于内存分配与回收原则)
   2. [死锁](#死锁)
      1. [产生死锁的必要条件](#产生死锁的必要条件)
      2. [避免死锁](#避免死锁)
      3. [案例与解决办法](#案例与解决办法)

<!-- /TOC -->

<a id="markdown-java面试基础" name="java面试基础"></a>
# Java面试基础

<a id="markdown-jvm与gc" name="jvm与gc"></a>
## JVM与GC

<a id="markdown-jvm" name="jvm"></a>
### JVM

![](img/jvm.jpg)

1. 程序计数器--与每个线程线程执行字节码行号有关--线程私有
2. 虚拟机栈--与Java方法有关创建栈帧--线程私有
3. 本地方法栈--与Java的native方法有关--线程私有
4. Java堆--与Java对象实例有关/垃圾收集器管理的主要区域--GC堆
5. Java方法区——线程共享；存储被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。

<a id="markdown-gc" name="gc"></a>
### GC

- 引用计数：对象被引用时，计数器加1，引用失效时减1，当计数器值为0时则回收；但难以解决对象之间相互循环引用的问题；
- 可达性分析：GC_Roots起始点向下通过引用链搜索，当一个对象到GC_Roots没有任何引用时，则对象是不可用的。第一次回收触发finalize方法，如果不在引用则回收；如果不回收，第二次触发finalize方法时肯定回收。

<a id="markdown-标记-清除" name="标记-清除"></a>
#### 标记-清除

标记需要回收的对象，标记后统一回收。
- 缺点：效率低，会产生不连续内存碎片，无法分配大对象的内存

<a id="markdown-复制算法----适用于新生代" name="复制算法----适用于新生代"></a>
#### 复制算法----适用于新生代

可用内存分为A、B两块；使用其中一块，用完了A以后将存活的对象复制到B，然后对A进行清理，如此每次都对整个半区进行内存回收，不用考虑内存碎片，只需移动堆顶指针按顺序分配内存即可。

<a id="markdown-标记-整理----适用于老年代" name="标记-整理----适用于老年代"></a>
#### 标记-整理----适用于老年代

标记后不清理，而是让所有存活对象向一端移动，然后清理端外界以外的内存。

<a id="markdown-分代收集" name="分代收集"></a>
#### 分代收集

将Java堆分为新生代（大批对象死去，少量存活）、老年代（对象存活率高，没有额外空间分配担保）。
- 新生代：复制算法；
- 老年代：标记-整理算法。

<a id="markdown-关于内存分配与回收原则" name="关于内存分配与回收原则"></a>
### 关于内存分配与回收原则

对于Java堆中对所有对象的内存分配，首先在Eden中分配；然后大的对象直接老年代;在survivor中存活时间过长也进入老年代；新生代的对象满足老年代连续空间则进入老年代,否则对老年代Full_GC。在给对象分配内存区域的时候，也时刻进行着判断内存回收，对新生代Minor_GC(复制算法)，对老年代Full_GC(标记-整理算法)。

<a id="markdown-死锁" name="死锁"></a>
## 死锁
>>定义
1. 集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。
2. 指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力作用，他们将无法推进下去。
产生锁的资源：线程池、网络连接池、通知事件，磁盘、带宽
<a id="markdown-产生死锁的必要条件" name="产生死锁的必要条件"></a>
### 产生死锁的必要条件
1. 资源互斥条件： 进程对于所分配到的资源具有排他性，一个资源只能由一个进程占用，知道该进程释放该资源。
2. 不可剥夺条件： 进程无法剥夺其他进程的资源，知道其他进程释放资源后才可能请求到。
3. 请求保持条件： 进程会请求所有需要的资源，如果过程中因为缺少资源而阻塞，已请求到的资源不会释放。
4. 循环等待条件： 死锁发生时，一定有两个或以上的进程形成环路，在等待下一个进程的某些资源，导致永久阻塞。
<a id="markdown-避免死锁" name="避免死锁"></a>
### 避免死锁
1. 以确定顺序获得锁\
   hashCode排序，顺序获得；多进程时使用银行家算法试探是否安全。
   **银行家算法**：当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。
2. 超时放弃
   按照固定时长等待锁，超时以后**主动释放之前已经获得的所有的锁**。
<a id="markdown-案例与解决办法" name="案例与解决办法"></a>
### 案例与解决办法
1. 线程池死锁：扩大线程池线程数 or 使任务结果之间不再互相依赖。
2. 两个线程A和B，两个数据库连接池N1和N2，A先N1后N2;B先N2后N1；且两个线程在完成执行之前都不释放自己已经持有的链接，因此也造成了死锁。








