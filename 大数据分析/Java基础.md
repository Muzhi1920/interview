<!-- TOC -->

1. [Java面试基础](#java面试基础)
   1. [JVM与GC](#jvm与gc)
      1. [JVM](#jvm)
      2. [GC](#gc)
         1. [标记-清除](#标记-清除)
         2. [复制算法----适用于新生代](#复制算法----适用于新生代)
         3. [标记-整理----适用于老年代](#标记-整理----适用于老年代)
         4. [分代收集](#分代收集)
      3. [关于内存分配与回收原则](#关于内存分配与回收原则)

<!-- /TOC -->

<a id="markdown-java面试基础" name="java面试基础"></a>
# Java面试基础

<a id="markdown-jvm与gc" name="jvm与gc"></a>
## JVM与GC

<a id="markdown-jvm" name="jvm"></a>
### JVM

![](img/jvm.jpg)

1. 程序计数器--与每个线程线程执行字节码行号有关--线程私有
2. 虚拟机栈--与Java方法有关创建栈帧--线程私有
3. 本地方法栈--与Java的native方法有关--线程私有
4. Java堆--与Java对象实例有关/垃圾收集器管理的主要区域--GC堆
5. Java方法区——线程共享；存储被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。

<a id="markdown-gc" name="gc"></a>
### GC

- 引用计数：对象被引用时，计数器加1，引用失效时减1，当计数器值为0时则回收；但难以解决对象之间相互循环引用的问题；
- 可达性分析：GC_Roots起始点向下通过引用链搜索，当一个对象到GC_Roots没有任何引用时，则对象是不可用的。第一次回收触发finalize方法，如果不在引用则回收；如果不回收，第二次触发finalize方法时肯定回收。

<a id="markdown-标记-清除" name="标记-清除"></a>
#### 标记-清除

标记需要回收的对象，标记后统一回收。
- 缺点：效率低，会产生不连续内存碎片，无法分配大对象的内存

<a id="markdown-复制算法----适用于新生代" name="复制算法----适用于新生代"></a>
#### 复制算法----适用于新生代

可用内存分为A、B两块；使用其中一块，用完了A以后将存活的对象复制到B，然后对A进行清理，如此每次都对整个半区进行内存回收，不用考虑内存碎片，只需移动堆顶指针按顺序分配内存即可。

<a id="markdown-标记-整理----适用于老年代" name="标记-整理----适用于老年代"></a>
#### 标记-整理----适用于老年代

标记后不清理，而是让所有存活对象向一端移动，然后清理端外界以外的内存。

<a id="markdown-分代收集" name="分代收集"></a>
#### 分代收集

将Java堆分为新生代（大批对象死去，少量存活）、老年代（对象存活率高，没有额外空间分配担保）。
- 新生代：复制算法；
- 老年代：标记-整理算法。

<a id="markdown-关于内存分配与回收原则" name="关于内存分配与回收原则"></a>
### 关于内存分配与回收原则

对于Java堆中对所有对象的内存分配，首先在Eden中分配；然后大的对象直接老年代;在survivor中存活时间过长也进入老年代；新生代的对象满足老年代连续空间则进入老年代,否则对老年代Full_GC。在给对象分配内存区域的时候，也时刻进行着判断内存回收，对新生代Minor_GC(复制算法)，对老年代Full_GC(标记-整理算法)。









