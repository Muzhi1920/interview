# Spark
### 1、Spark job资源分配

|config|num|annotation|
|--------|--------|--------|
|driver-memory	|4g	|driver使用的内存，不可超过单机的 core 总数。
|num-executors	|2 |创建多少个 executor。
|executor-memory	|2g	|各个 executor使用的最大内存，不可超过单机的最大可使用内存。
|executor-cores	|2	|各个 executor 使用的并发线程数目，也即每个 executor 最大可并发执行的 Task 数目。
![avatar](img/cluster.jpg)
### 2、 Faiss
>>支持两种相似性计算方法：L2距离（即欧式距离）和点乘（归一化的向量点乘即cosine相似度）

#### 1、索引Index

#### 2、PCA降维
PCA数据降维减少内存，加快机器学习的速度。从数据存储的角度，图片处理中通过PCA可以将图片从高维空间（p维）转换到低维空间（q维, 其中p > q ），其具体操作便是是将高维空间中的图片向量（n*p）乘以一个转换矩阵M（p*q），得到一个低维空间中的向量（n*q）；转换矩阵M是与图库有关，是可以由图库数据计算出来的。在Faiss的一些预处理中，我们会引入一些参数，这些参数又无法一开始由人工来指定，只能通过喂样本来训练出来。

#### 3、Product quantization(乘积量化)
 PQ算法可以理解为首先把原始的向量空间分解为m个低维向量空间的笛卡尔积，并对分解得到的低维向量空间分别做量化。即是把原始D维向量（比如D=128）分成m组（比如m=4），每组就是D∗=D/m维的子向量（比如D∗=D/m=128/4=32），各自用kmeans算法学习到一个码本，然后这些码本的笛卡尔积就是原始D维向量对应的码本。用qj表示第j组子向量，用Cj表示其对应学习到的码本，那么原始D维向量对应的码本就是C=C1×C2×…×Cm。用k∗表示子向量的聚类中心点数或者说码本大小，那么原始D维向量对应的聚类中心点数或者说码本大小就是k=(k∗)m。


### 3、指标
|config|annotation|
|--------|--------|
display_count |  展示量
session_display_count  | 去重展示量
click_count   |	点击量
long_click_count|长点击量
short_click_count|短点击量
mid_click_count |中点击量
playtime | 播放时长
click_uv| 点击UV
display_uv | 展示UV
video_count	| 视频个数（新加）
ctr	 | 点击量/展示量
lctr	 | 长点击量/展示量
uctr | 	点击UV/展示UV
人均feed数	 | feed展示量/展示UV
点击人均播放时长 | 	总播放时长/点击UV
展示人均播放时长PPUI | 	总播放时长/展示UV
平均播放时长	 | 总播放时长/feed展示次数

### MMR && DPP

MMR的原则是，结果文档之间彼此越不相似，整个结果文档集的多样化程度越高

### MR实现矩阵相乘

![avatar](img/MRMatrix.png)

### 生成随机数
```cpp
while(1){
    x = a*rand_a()+rand_a();
    if x < N{  //N=max(N%b==0,N<-[0,a^2+a])
        return x%b;
```